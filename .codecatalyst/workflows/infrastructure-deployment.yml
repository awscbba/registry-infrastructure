Name: Infrastructure_Deployment_Pipeline
SchemaVersion: "1.0"

Triggers:
  - Type: PUSH
    Branches:
      - main
  - Type: PULLREQUEST
    Branches:
      - main
    Events:
      - PULLREQUEST_CREATED
      - PULLREQUEST_REVISION_CREATED
  - Type: MANUAL

Actions:
  CheckAPISync:
    Identifier: aws/build@v1
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
    Configuration:
      Steps:
        - Run: |
            echo "üîç Checking API Code Synchronization"
            echo "==================================="
            echo "üìÖ Stage Start: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "üè∑Ô∏è Stage: CheckAPISync (Always Executes)"
            echo ""
            
            # Execute execution mode detection
            echo "üéØ Detecting execution mode..."
            chmod +x scripts/execution-mode-detection.sh
            ./scripts/execution-mode-detection.sh
            
            # Source the execution mode environment variables
            source execution-mode-env.sh
            
            # Source workflow logger for consistent logging
            chmod +x scripts/workflow-logger.sh
            source scripts/workflow-logger.sh
            
            echo ""
            echo "üìä Stage Execution Context:"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Trigger Type: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Stage Decision: EXECUTE (CheckAPISync always runs in both modes)"
            echo "  Stage Purpose: $([ "$EXECUTION_MODE" = "validation" ] && echo "Validate API sync for pull request feedback" || echo "Check API sync before deployment")"
            echo ""
            
            # Display mode-specific execution information
            if [ "$EXECUTION_MODE" = "validation" ]; then
                log_validation_only_message "$TRIGGER_TYPE" "$BRANCH_NAME"
            else
                log_deployment_mode_message "$TRIGGER_TYPE" "$BRANCH_NAME"
            fi
            
            # Check if this deployment was triggered by API sync
            if [ -f "lambda/main.py" ] && [ -d "lambda/src" ]; then
                echo "‚úÖ API code synchronized from registry-api repository"
                echo "üìä API sync detected:"
                echo "  - main.py: $([ -f "lambda/main.py" ] && echo "Present" || echo "Missing")"
                echo "  - src/ directory: $([ -d "lambda/src" ] && echo "Present" || echo "Missing")"
                echo "  - requirements.txt: $([ -f "lambda/requirements.txt" ] && echo "Present" || echo "Missing")"
                
                # Check for sync metadata
                if [ -f "lambda/sync-metadata.json" ]; then
                    echo "üìã Sync metadata found:"
                    cat lambda/sync-metadata.json
                fi
                
                echo "üîÑ Proceeding with infrastructure deployment using synchronized API code"
            else
                echo "‚ÑπÔ∏è No API sync detected - using existing lambda handlers"
                echo "üìä Current lambda structure:"
                ls -la lambda/ || echo "Lambda directory not found"
            fi
            
            # Create deployment context
            DEPLOYMENT_TYPE=$([ -f "lambda/main.py" ] && echo "api_sync" || echo "infrastructure_only")
            API_SYNC_DETECTED=$([ -f "lambda/main.py" ] && echo "true" || echo "false")
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            BRANCH=${CODECATALYST_SOURCE_BRANCH_NAME:-main}
            COMMIT=${CODECATALYST_SOURCE_BRANCH_REF:-unknown}
            
            # Merge execution context with deployment context
            echo "{" > deployment-context.json
            echo "  \"deployment_type\": \"$DEPLOYMENT_TYPE\"," >> deployment-context.json
            echo "  \"timestamp\": \"$TIMESTAMP\"," >> deployment-context.json
            echo "  \"branch\": \"$BRANCH\"," >> deployment-context.json
            echo "  \"commit\": \"$COMMIT\"," >> deployment-context.json
            echo "  \"api_sync_detected\": \"$API_SYNC_DETECTED\"," >> deployment-context.json
            echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> deployment-context.json
            echo "  \"trigger_type\": \"$TRIGGER_TYPE\"," >> deployment-context.json
            echo "  \"is_main_branch\": \"$IS_MAIN_BRANCH\"," >> deployment-context.json
            echo "  \"skip_deployment\": \"$SKIP_DEPLOYMENT\"," >> deployment-context.json
            echo "  \"skip_testing\": \"$SKIP_TESTING\"" >> deployment-context.json
            echo "}" >> deployment-context.json
            
            cat deployment-context.json
            echo ""
            echo "üìä Stage Completion Summary:"
            echo "  Stage: CheckAPISync"
            echo "  Status: COMPLETED"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Next Stage: PrepareAPIIntegration (will execute)"
            echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
            echo "‚úÖ API sync check completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentContext
          Files:
            - "deployment-context.json"
            - "execution-context.json"
            - "execution-mode-env.sh"

  PrepareAPIIntegration:
    Identifier: aws/build@v1
    DependsOn:
      - CheckAPISync
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
    Configuration:
      Steps:
        - Run: |
            echo "üîß Preparing API Integration"
            echo "==========================="
            echo "üìÖ Stage Start: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "üè∑Ô∏è Stage: PrepareAPIIntegration (Always Executes)"
            echo ""
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            # Read deployment context
            DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-context.json)
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            
            echo "üìä Stage Execution Context:"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Trigger Type: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo "  Stage Decision: EXECUTE (PrepareAPIIntegration always runs in both modes)"
            echo "  Stage Purpose: $([ "$EXECUTION_MODE" = "validation" ] && echo "Prepare API integration for validation" || echo "Prepare API integration for deployment")"
            echo ""
            echo "üìã Integration Context:"
            echo "  Deployment type: $DEPLOYMENT_TYPE"
            echo "  API sync detected: $API_SYNC_DETECTED"
            echo ""
            
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "üîÑ Integrating synchronized API code with infrastructure"
                
                # Create integrated Lambda handler that uses the new API structure
                echo "Creating integrated API handler..."
                mkdir -p lambda
                
                # Create a basic integrated handler file
                echo "# Integrated API Handler - Bridges registry-api code with Lambda infrastructure" > lambda/integrated_api_handler.py
                echo "import json" >> lambda/integrated_api_handler.py
                echo "import logging" >> lambda/integrated_api_handler.py
                echo "import os" >> lambda/integrated_api_handler.py
                echo "import sys" >> lambda/integrated_api_handler.py
                echo "from typing import Dict, Any" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "# Add the src directory to Python path for registry-api imports" >> lambda/integrated_api_handler.py
                echo "sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "# Configure logging" >> lambda/integrated_api_handler.py
                echo "logging.basicConfig(level=logging.INFO)" >> lambda/integrated_api_handler.py
                echo "logger = logging.getLogger(__name__)" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:" >> lambda/integrated_api_handler.py
                echo "    try:" >> lambda/integrated_api_handler.py
                echo "        logger.info(f'Received event: {json.dumps(event, default=str)}')" >> lambda/integrated_api_handler.py
                echo "        try:" >> lambda/integrated_api_handler.py
                echo "            from main import app" >> lambda/integrated_api_handler.py
                echo "            from mangum import Mangum" >> lambda/integrated_api_handler.py
                echo "            handler = Mangum(app, lifespan='off')" >> lambda/integrated_api_handler.py
                echo "            response = handler(event, context)" >> lambda/integrated_api_handler.py
                echo "            logger.info(f'Response status: {response.get(\"statusCode\", \"unknown\")}')" >> lambda/integrated_api_handler.py
                echo "            return response" >> lambda/integrated_api_handler.py
                echo "        except ImportError as e:" >> lambda/integrated_api_handler.py
                echo "            logger.error(f'Failed to import registry-api components: {str(e)}')" >> lambda/integrated_api_handler.py
                echo "            try:" >> lambda/integrated_api_handler.py
                echo "                from enhanced_api_handler import lambda_handler as fallback_handler" >> lambda/integrated_api_handler.py
                echo "                logger.info('Using fallback enhanced_api_handler')" >> lambda/integrated_api_handler.py
                echo "                return fallback_handler(event, context)" >> lambda/integrated_api_handler.py
                echo "            except ImportError:" >> lambda/integrated_api_handler.py
                echo "                return {'statusCode': 500, 'body': json.dumps({'error': 'API handler not available'})}" >> lambda/integrated_api_handler.py
                echo "    except Exception as e:" >> lambda/integrated_api_handler.py
                echo "        logger.error(f'Lambda handler error: {str(e)}', exc_info=True)" >> lambda/integrated_api_handler.py
                echo "        return {'statusCode': 500, 'body': json.dumps({'error': 'Internal Server Error'})}" >> lambda/integrated_api_handler.py
                
                # Update requirements.txt to include registry-api dependencies
                if [ -f "lambda/requirements.txt" ]; then
                    echo "üì¶ Merging requirements from registry-api"
                    
                    # Create merged requirements
                    # Create merged requirements file
                    echo "# Infrastructure requirements (existing)" > lambda/requirements_merged.txt
                    echo "boto3==1.34.144" >> lambda/requirements_merged.txt
                    echo "botocore==1.34.144" >> lambda/requirements_merged.txt
                    echo "pydantic==2.10.3" >> lambda/requirements_merged.txt
                    echo "bcrypt==4.1.3" >> lambda/requirements_merged.txt
                    echo "pyjwt==2.8.0" >> lambda/requirements_merged.txt
                    echo "python-json-logger==2.0.7" >> lambda/requirements_merged.txt
                    echo "" >> lambda/requirements_merged.txt
                    echo "# Registry-API requirements (synchronized)" >> lambda/requirements_merged.txt
                    echo "fastapi==0.111.0" >> lambda/requirements_merged.txt
                    echo "mangum==0.17.0" >> lambda/requirements_merged.txt
                    echo "python-multipart>=0.0.7" >> lambda/requirements_merged.txt
                    echo "pytest==8.2.2" >> lambda/requirements_merged.txt
                    echo "pytest-mock==3.14.0" >> lambda/requirements_merged.txt
                    echo "moto==5.0.9" >> lambda/requirements_merged.txt
                    
                    # Replace original requirements
                    mv lambda/requirements_merged.txt lambda/requirements.txt
                    
                    echo "‚úÖ Requirements merged successfully"
                else
                    echo "‚ö†Ô∏è No requirements.txt found in lambda directory"
                fi
                
                echo "‚úÖ API integration prepared successfully"
            else
                echo "‚ÑπÔ∏è No API sync detected - using existing infrastructure handlers"
            fi
            
            # Create integration summary
            # Create integration summary
            echo "API Integration Summary" > api-integration-summary.txt
            echo "======================" >> api-integration-summary.txt
            echo "Timestamp: $(date)" >> api-integration-summary.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> api-integration-summary.txt
            echo "API Sync Detected: $API_SYNC_DETECTED" >> api-integration-summary.txt
            echo "" >> api-integration-summary.txt
            echo "Integration Actions:" >> api-integration-summary.txt
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "‚úÖ Created integrated_api_handler.py" >> api-integration-summary.txt
                echo "‚úÖ Merged requirements.txt" >> api-integration-summary.txt
            else
                echo "‚ÑπÔ∏è No integration needed" >> api-integration-summary.txt
                echo "‚ÑπÔ∏è Using existing requirements" >> api-integration-summary.txt
            fi
            echo "" >> api-integration-summary.txt
            echo "Handler Priority:" >> api-integration-summary.txt
            echo "1. integrated_api_handler.py (if API sync detected)" >> api-integration-summary.txt
            echo "2. enhanced_api_handler.py (fallback)" >> api-integration-summary.txt
            echo "3. api_handler.py (legacy fallback)" >> api-integration-summary.txt
            
            cat api-integration-summary.txt
            echo ""
            echo "üìä Stage Completion Summary:"
            echo "  Stage: PrepareAPIIntegration"
            echo "  Status: COMPLETED"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Integration Type: $DEPLOYMENT_TYPE"
            echo "  Next Stage: ValidateInfrastructure (will execute)"
            echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
            echo "‚úÖ API integration preparation completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: apiIntegration
          Files:
            - "api-integration-summary.txt"
            - "lambda/integrated_api_handler.py"

  ValidateInfrastructure:
    Identifier: aws/build@v1
    DependsOn:
      - PrepareAPIIntegration
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
        - apiIntegration
    Configuration:
      Steps:
        - Run: |
            echo "‚ö° Optimized Infrastructure Validation"
            echo "===================================="
            echo "üìÖ Stage Start: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "üè∑Ô∏è Stage: ValidateInfrastructure (Always Executes - OPTIMIZED)"
            echo "üéØ Target: Fast feedback within 5-10 minutes"
            echo ""
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "üìä Stage Execution Context:"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Trigger Type: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo "  Stage Decision: EXECUTE (ValidateInfrastructure always runs in both modes)"
            echo "  Stage Purpose: $([ "$EXECUTION_MODE" = "validation" ] && echo "Fast validation for pull request feedback" || echo "Validate infrastructure before deployment")"
            echo "  Optimization Level: HIGH (caching, parallel processing, minimal dependencies)"
            echo ""
            
            # Install essential tools only
            echo "üì¶ Installing essential tools..."
            curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin
            
            # Make optimization scripts executable
            chmod +x scripts/optimized-validation.sh
            chmod +x scripts/performance-profiler.sh
            
            # Choose validation approach based on execution mode
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "üöÄ Running OPTIMIZED validation for fast pull request feedback..."
                echo "  Target: Under 5-10 minutes"
                echo "  Features: Caching, parallel processing, minimal logging"
                echo ""
                
                # Run optimized validation script
                if ./scripts/optimized-validation.sh; then
                    echo "‚úÖ Optimized validation completed successfully"
                    VALIDATION_STATUS="success"
                else
                    echo "‚ùå Optimized validation failed"
                    VALIDATION_STATUS="failed"
                fi
                
            else
                echo "üîç Running COMPREHENSIVE validation for deployment preparation..."
                echo "  Target: Thorough validation with detailed reporting"
                echo "  Features: Full validation, detailed logging, comprehensive checks"
                echo ""
                
                # Run comprehensive validation (existing logic)
                # Initialize validation results
                VALIDATION_ERRORS=0
                VALIDATION_WARNINGS=0
                VALIDATION_REPORT="validation-report.txt"
                
                echo "Infrastructure Validation Report" > $VALIDATION_REPORT
                echo "===============================" >> $VALIDATION_REPORT
                echo "Timestamp: $(date)" >> $VALIDATION_REPORT
                echo "Execution Mode: $EXECUTION_MODE" >> $VALIDATION_REPORT
                echo "Trigger Type: $TRIGGER_TYPE" >> $VALIDATION_REPORT
                echo "Branch: $BRANCH_NAME" >> $VALIDATION_REPORT
                echo "" >> $VALIDATION_REPORT
                
                # Function to log validation results
                log_validation() {
                    local level="$1"
                    local message="$2"
                    local suggestion="${3:-}"
                    
                    echo "[$level] $message" | tee -a $VALIDATION_REPORT
                    if [ -n "$suggestion" ]; then
                        echo "  üí° Suggestion: $suggestion" | tee -a $VALIDATION_REPORT
                    fi
                    
                    if [ "$level" = "ERROR" ]; then
                        VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
                    elif [ "$level" = "WARNING" ]; then
                        VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
                    fi
                }
                
                # 1. AWS Credentials Validation
                echo ""
                echo "üîê Step 1: AWS Credentials Validation"
                echo "====================================="
                
                if aws sts get-caller-identity > aws-identity.json 2>&1; then
                    ACCOUNT_ID=$(jq -r '.Account' aws-identity.json)
                    USER_ARN=$(jq -r '.Arn' aws-identity.json)
                    echo "‚úÖ AWS credentials are valid"
                    echo "  Account ID: $ACCOUNT_ID"
                    echo "  User/Role: $USER_ARN"
                    log_validation "INFO" "AWS credentials validated successfully"
                    log_validation "INFO" "Account ID: $ACCOUNT_ID"
                    log_validation "INFO" "User/Role: $USER_ARN"
                else
                    echo "‚ùå AWS credentials are invalid"
                    log_validation "ERROR" "AWS credentials validation failed" "Check your AWS credentials and permissions"
                    VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
                fi
                
                # 2. IAM Permission Validation
                echo ""
                echo "üîë Step 2: IAM Permission Validation"
                echo "===================================="
                
                echo "Testing required IAM permissions..."
                
                # Test DynamoDB permissions
                if aws dynamodb describe-limits --region us-east-1 >/dev/null 2>&1; then
                    echo "  ‚úÖ DynamoDB permissions: OK"
                    log_validation "INFO" "DynamoDB permissions validated"
                else
                    echo "  ‚ùå DynamoDB permissions: FAILED"
                    log_validation "ERROR" "DynamoDB permissions insufficient" "Ensure your role has DynamoDB read/write permissions"
                fi
                
                # Test Lambda permissions
                if aws lambda list-functions --max-items 1 >/dev/null 2>&1; then
                    echo "  ‚úÖ Lambda permissions: OK"
                    log_validation "INFO" "Lambda permissions validated"
                else
                    echo "  ‚ùå Lambda permissions: FAILED"
                    log_validation "ERROR" "Lambda permissions insufficient" "Ensure your role has Lambda create/update permissions"
                fi
                
                # Test S3 permissions
                if aws s3api list-buckets >/dev/null 2>&1; then
                    echo "  ‚úÖ S3 permissions: OK"
                    log_validation "INFO" "S3 permissions validated"
                else
                    echo "  ‚ùå S3 permissions: FAILED"
                    log_validation "ERROR" "S3 permissions insufficient" "Ensure your role has S3 bucket management permissions"
                fi
                
                # Test IAM permissions
                if aws iam get-user >/dev/null 2>&1 || aws iam get-role --role-name CodeCatalystWorkflowDevelopmentRole-AWSCocha >/dev/null 2>&1; then
                    echo "  ‚úÖ IAM permissions: OK"
                    log_validation "INFO" "IAM permissions validated"
                else
                    echo "  ‚ö†Ô∏è IAM permissions: LIMITED"
                    log_validation "WARNING" "IAM permissions may be limited" "This might affect role creation during deployment"
                fi
                
                # Continue with comprehensive validation...
                # (Rest of the comprehensive validation logic would go here)
                
                # For now, set success status for comprehensive validation
                if [ $VALIDATION_ERRORS -eq 0 ]; then
                    VALIDATION_STATUS="success"
                    echo "‚úÖ Comprehensive validation completed successfully"
                else
                    VALIDATION_STATUS="failed"
                    echo "‚ùå Comprehensive validation failed with $VALIDATION_ERRORS errors"
                fi
            fi
            
            # Create final validation results
            if [ "$VALIDATION_STATUS" = "success" ]; then
                echo ""
                echo "‚úÖ Infrastructure validation completed successfully"
                echo "üìä Stage Completion Summary:"
                echo "  Stage: ValidateInfrastructure"
                echo "  Status: COMPLETED"
                echo "  Execution Mode: $EXECUTION_MODE"
                echo "  Optimization: $([ "$EXECUTION_MODE" = "validation" ] && echo "HIGH (fast feedback)" || echo "STANDARD (comprehensive)")"
                echo "  Next Stage: $([ "$SKIP_DEPLOYMENT" = "false" ] && echo "DeployInfrastructure (will execute)" || echo "DeployInfrastructure (will skip - placeholder artifacts)")"
                echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
                
                # Ensure validation results exist
                if [ ! -f "validation-results.json" ]; then
                    echo '{"status": "success", "execution_mode": "'$EXECUTION_MODE'", "optimization": "enabled"}' > validation-results.json
                fi
                
            else
                echo ""
                echo "‚ùå Infrastructure validation failed"
                echo "üîç Please review the validation report for detailed error information and suggested fixes."
                
                # Ensure validation results exist for failed case
                if [ ! -f "validation-results.json" ]; then
                    echo '{"status": "failed", "execution_mode": "'$EXECUTION_MODE'", "optimization": "enabled"}' > validation-results.json
                fi
                
                exit 1
            fi
            if npm install -g aws-cdk@2.80.0; then
                echo "‚úÖ CDK CLI installed"
                log_validation "INFO" "CDK CLI v2.80.0 installed successfully"
            else
                echo "‚ùå Failed to install CDK CLI"
                log_validation "ERROR" "CDK CLI installation failed" "Check npm and Node.js setup"
            fi
            
            # CDK version check
            CDK_VERSION=$(cdk --version 2>/dev/null || echo "unknown")
            echo "CDK version: $CDK_VERSION"
            log_validation "INFO" "CDK version: $CDK_VERSION"
            
            # CDK synthesis validation with detailed error reporting
            echo "üîÑ Performing CDK synthesis validation..."
            if source .venv/bin/activate && cdk synth --quiet > cdk-synth-output.json 2>cdk-synth-errors.txt; then
                echo "‚úÖ CDK synthesis validation - SUCCESS"
                log_validation "INFO" "CDK synthesis completed successfully"
                
                # Analyze synthesized template for potential issues
                if [ -f "cdk.out/PeopleRegisterInfrastructureStack.template.json" ]; then
                    TEMPLATE_SIZE=$(wc -c < "cdk.out/PeopleRegisterInfrastructureStack.template.json")
                    echo "  üìä CloudFormation template size: $TEMPLATE_SIZE bytes"
                    log_validation "INFO" "CloudFormation template generated ($TEMPLATE_SIZE bytes)"
                    
                    # Check for template size limits (CloudFormation has a 51,200 byte limit for direct uploads)
                    if [ $TEMPLATE_SIZE -gt 51200 ]; then
                        echo "  ‚ö†Ô∏è Template size exceeds direct upload limit"
                        log_validation "WARNING" "CloudFormation template size ($TEMPLATE_SIZE bytes) exceeds 51KB limit" "Template will be uploaded to S3 during deployment"
                    fi
                    
                    # Count resources
                    RESOURCE_COUNT=$(jq '.Resources | length' "cdk.out/PeopleRegisterInfrastructureStack.template.json" 2>/dev/null || echo "unknown")
                    echo "  üìä CloudFormation resources: $RESOURCE_COUNT"
                    log_validation "INFO" "CloudFormation template contains $RESOURCE_COUNT resources"
                    
                    # Check for resource limits (CloudFormation has a 500 resource limit)
                    if [ "$RESOURCE_COUNT" != "unknown" ] && [ $RESOURCE_COUNT -gt 400 ]; then
                        echo "  ‚ö†Ô∏è High resource count detected"
                        log_validation "WARNING" "High resource count ($RESOURCE_COUNT) approaching CloudFormation limit" "Consider splitting into multiple stacks if approaching 500 resources"
                    fi
                fi
            else
                echo "‚ùå CDK synthesis validation - FAILED"
                log_validation "ERROR" "CDK synthesis failed" "Review CDK stack configuration and dependencies"
                
                # Provide detailed error analysis
                if [ -f "cdk-synth-errors.txt" ]; then
                    echo "üîç CDK Synthesis Error Details:"
                    echo "==============================="
                    cat cdk-synth-errors.txt
                    
                    # Analyze common error patterns and provide suggestions
                    if grep -q "ModuleNotFoundError" cdk-synth-errors.txt; then
                        log_validation "ERROR" "Python module import error detected" "Check that all required Python packages are installed in the virtual environment"
                    fi
                    
                    if grep -q "ValidationError" cdk-synth-errors.txt; then
                        log_validation "ERROR" "CDK validation error detected" "Review CDK construct configuration and property values"
                    fi
                    
                    if grep -q "Cannot find module" cdk-synth-errors.txt; then
                        log_validation "ERROR" "Node.js module error detected" "Check that CDK CLI and dependencies are properly installed"
                    fi
                    
                    if grep -q "Credentials" cdk-synth-errors.txt; then
                        log_validation "ERROR" "AWS credentials error during synthesis" "Verify AWS credentials and permissions"
                    fi
                fi
                
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            fi
            
            # 5. Generate Validation Summary
            echo ""
            echo "üìã Step 5: Validation Summary"
            echo "============================"
            
            echo "" >> $VALIDATION_REPORT
            echo "VALIDATION SUMMARY" >> $VALIDATION_REPORT
            echo "==================" >> $VALIDATION_REPORT
            echo "Total Errors: $VALIDATION_ERRORS" >> $VALIDATION_REPORT
            echo "Total Warnings: $VALIDATION_WARNINGS" >> $VALIDATION_REPORT
            echo "" >> $VALIDATION_REPORT
            
            if [ $VALIDATION_ERRORS -eq 0 ]; then
                echo "‚úÖ Infrastructure validation completed successfully"
                echo "  Errors: $VALIDATION_ERRORS"
                echo "  Warnings: $VALIDATION_WARNINGS"
                log_validation "INFO" "Infrastructure validation completed successfully"
                
                # Create validation success artifact
                echo "{" > validation-results.json
                echo "  \"status\": \"success\"," >> validation-results.json
                echo "  \"errors\": \"$VALIDATION_ERRORS\"," >> validation-results.json
                echo "  \"warnings\": \"$VALIDATION_WARNINGS\"," >> validation-results.json
                echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> validation-results.json
                echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> validation-results.json
                echo "  \"cdk_synthesis\": \"success\"," >> validation-results.json
                echo "  \"iam_permissions\": \"validated\"," >> validation-results.json
                echo "  \"resource_configuration\": \"validated\"" >> validation-results.json
                echo "}" >> validation-results.json
            else
                echo "‚ùå Infrastructure validation failed"
                echo "  Errors: $VALIDATION_ERRORS"
                echo "  Warnings: $VALIDATION_WARNINGS"
                echo ""
                echo "üîç Please review the validation report for detailed error information and suggested fixes."
                log_validation "ERROR" "Infrastructure validation failed with $VALIDATION_ERRORS errors"
                
                # Create validation failure artifact
                echo "{" > validation-results.json
                echo "  \"status\": \"failed\"," >> validation-results.json
                echo "  \"errors\": \"$VALIDATION_ERRORS\"," >> validation-results.json
                echo "  \"warnings\": \"$VALIDATION_WARNINGS\"," >> validation-results.json
                echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> validation-results.json
                echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> validation-results.json
                echo "  \"cdk_synthesis\": \"failed\"," >> validation-results.json
                echo "  \"iam_permissions\": \"checked\"," >> validation-results.json
                echo "  \"resource_configuration\": \"checked\"" >> validation-results.json
                echo "}" >> validation-results.json
                
                # Display validation report
                echo ""
                echo "üìã VALIDATION REPORT:"
                echo "===================="
                cat $VALIDATION_REPORT
                
                exit 1
            fi
            
            echo ""
            echo "üìä Stage Completion Summary:"
            echo "  Stage: ValidateInfrastructure"
            echo "  Status: COMPLETED"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Validation Errors: $VALIDATION_ERRORS"
            echo "  Validation Warnings: $VALIDATION_WARNINGS"
            echo "  Next Stage: $([ "$SKIP_DEPLOYMENT" = "false" ] && echo "DeployInfrastructure (will execute)" || echo "DeployInfrastructure (will skip - placeholder artifacts)")"
            echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
            echo ""
            echo "üìã Full validation report saved to: $VALIDATION_REPORT"
            echo "üìä Validation results saved to: validation-results.json"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: validationResults
          Files:
            - "validation-report.txt"
            - "validation-results.json"
            - "cdk-synth-output.json"
            - "cdk-synth-errors.txt"

  DeployInfrastructure:
    Identifier: aws/build@v1
    DependsOn:
      - ValidateInfrastructure
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
        - apiIntegration
        - validationResults
    Configuration:
      Steps:
        - Run: |
            echo "üöÄ Infrastructure Deployment Stage"
            echo "================================="
            echo "üìÖ Stage Start: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "üè∑Ô∏è Stage: DeployInfrastructure (Conditional Execution)"
            echo ""
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "üìä Stage Execution Context:"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Trigger Type: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            echo "üéØ Stage Decision Logic:"
            if [ "$SKIP_DEPLOYMENT" = "true" ]; then
                echo "  ‚è≠Ô∏è Deployment will be SKIPPED ($EXECUTION_MODE mode)"
                echo "  üìù Reason: $EXECUTION_MODE mode does not deploy to live infrastructure"
                echo "  üîß Action: Create placeholder artifacts for downstream compatibility"
                echo "  ‚ö° Benefit: Fast feedback without infrastructure changes"
            else
                echo "  ‚úÖ Deployment will be EXECUTED ($EXECUTION_MODE mode)"
                echo "  üìù Reason: $EXECUTION_MODE mode deploys to live infrastructure"
                echo "  üîß Action: Execute CDK deployment to AWS"
                echo "  üèóÔ∏è Impact: Live infrastructure changes will be applied"
            fi
            echo ""
            
            # Read deployment context for consistent artifact creation
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected // false' deployment-context.json 2>/dev/null || echo "false")
            DEPLOYMENT_TYPE=$(jq -r '.deployment_type // "infrastructure_only"' deployment-context.json 2>/dev/null || echo "infrastructure_only")
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            
            echo "üìã Deployment Context:"
            echo "  API Sync Detected: $API_SYNC_DETECTED"
            echo "  Deployment Type: $DEPLOYMENT_TYPE"
            echo "  Timestamp: $TIMESTAMP"
            echo ""
            
            # Determine execution mode and create appropriate artifacts
            if [ "$SKIP_DEPLOYMENT" = "true" ]; then
                echo "üîç VALIDATION MODE - Creating placeholder artifacts"
                echo "=================================================="
                echo "üìä Stage Execution Decision: SKIP DEPLOYMENT"
                echo "  Execution mode: $EXECUTION_MODE"
                echo "  Trigger type: $TRIGGER_TYPE"
                echo "  Branch: $BRANCH_NAME"
                echo "  Rationale: Validation mode preserves live infrastructure"
                echo "  Action: Creating placeholder artifacts for downstream stages"
                echo ""
                
                # Use artifact handler to create structured placeholder artifacts
                echo "üîß Using artifact handler to create placeholder artifacts..."
                chmod +x scripts/artifact-handler.sh
                
                # Create placeholder deployment summary with proper structure
                if ./scripts/artifact-handler.sh create-placeholder deploymentSummary "$EXECUTION_MODE" "$TRIGGER_TYPE" "$BRANCH_NAME" "."; then
                    echo "‚úÖ Placeholder deployment summary created successfully"
                else
                    echo "‚ùå Failed to create placeholder deployment summary"
                    exit 1
                fi
                
                # Validate artifact structure
                if ./scripts/artifact-handler.sh validate deploymentSummary "."; then
                    echo "‚úÖ Artifact structure validation passed"
                else
                    echo "‚ö†Ô∏è Artifact structure validation failed - continuing with available artifacts"
                fi
                
                # Test artifact consumption compatibility
                echo "üß™ Testing artifact consumption compatibility..."
                if ./scripts/artifact-handler.sh test-consumption deploymentSummary "."; then
                    echo "‚úÖ Artifact consumption test passed"
                else
                    echo "‚ö†Ô∏è Artifact consumption test failed - downstream stages may have issues"
                fi
                
                echo "‚úÖ Placeholder artifacts created successfully"
                echo ""
                echo "üìä Stage Completion Summary (Validation Mode):"
                echo "  Stage: DeployInfrastructure"
                echo "  Status: SKIPPED (placeholder artifacts created)"
                echo "  Execution Mode: $EXECUTION_MODE"
                echo "  Infrastructure Changes: None (validation mode)"
                echo "  Next Stage: PostDeploymentTests (will skip - placeholder artifacts)"
                echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
                echo ""
                echo "üìä Deployment Summary (Validation Mode):"
                cat deployment-summary.json | jq '.' 2>/dev/null || cat deployment-summary.json
                echo ""
                echo "üéØ Validation mode execution completed - ready for downstream stages"
                exit 0
            fi
            
            echo "üèóÔ∏è DEPLOYMENT MODE - Executing actual infrastructure deployment"
            echo "=============================================================="
            echo "üìä Stage Execution Decision: EXECUTE DEPLOYMENT"
            echo "  Execution mode: $EXECUTION_MODE"
            echo "  Trigger type: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Rationale: Deployment mode applies changes to live infrastructure"
            echo "  Action: Executing CDK deployment to AWS"
            echo ""
            
            # Setup Python environment for deployment
            echo "üîß Setting up deployment environment..."
            python3 -m venv .venv
            source .venv/bin/activate
            
            # Install CDK dependencies with error handling
            echo "üì¶ Installing CDK dependencies..."
            if ! pip install aws-cdk-lib==2.80.0 constructs>=10.0.0,\<11.0.0 boto3>=1.34.0 pydantic>=2.7.0; then
                echo "‚ùå Failed to install Python CDK dependencies"
                exit 1
            fi
            
            # Install CDK CLI with error handling
            echo "üì¶ Installing CDK CLI..."
            npm uninstall -g aws-cdk 2>/dev/null || echo "No existing CDK to uninstall"
            if ! npm install -g aws-cdk@2.80.0; then
                echo "‚ùå Failed to install CDK CLI"
                exit 1
            fi
            
            echo "‚úÖ Deployment environment setup completed"
            echo ""
            
            # Pre-deployment validation
            echo "üîç Pre-deployment validation..."
            if ! aws sts get-caller-identity > /dev/null 2>&1; then
                echo "‚ùå AWS credentials validation failed"
                exit 1
            fi
            echo "‚úÖ AWS credentials validated"
            
            # Start deployment with comprehensive logging
            echo "üèóÔ∏è Starting CDK deployment..."
            echo "Deployment type: $DEPLOYMENT_TYPE"
            echo "API sync detected: $API_SYNC_DETECTED"
            echo "Handler selection: $([ "$API_SYNC_DETECTED" = "true" ] && echo "integrated_api_handler" || echo "enhanced_api_handler")"
            echo ""
            
            # Record deployment start time
            DEPLOYMENT_START=$(date +%s)
            
            # Execute CDK deployment with detailed error handling
            echo "üöÄ Executing CDK deployment..."
            if source .venv/bin/activate && cdk deploy --require-approval never --outputs-file outputs.json 2>&1 | tee deployment.log; then
                DEPLOYMENT_END=$(date +%s)
                DEPLOYMENT_DURATION=$((DEPLOYMENT_END - DEPLOYMENT_START))
                
                echo "‚úÖ CDK deployment completed successfully"
                echo "‚è±Ô∏è Deployment duration: ${DEPLOYMENT_DURATION}s"
                echo ""
                
                # Extract and validate deployment outputs
                echo "üîç Extracting deployment outputs..."
                if [ -f "outputs.json" ]; then
                    # Extract outputs with fallback values
                    API_URL=$(jq -r '.PeopleRegisterInfrastructureStack.ApiUrl // "not_available"' outputs.json 2>/dev/null || echo "not_available")
                    FRONTEND_URL=$(jq -r '.PeopleRegisterInfrastructureStack.FrontendUrl // "not_available"' outputs.json 2>/dev/null || echo "not_available")
                    S3_BUCKET=$(jq -r '.PeopleRegisterInfrastructureStack.S3BucketName // "not_available"' outputs.json 2>/dev/null || echo "not_available")
                    
                    echo "üìä DEPLOYMENT OUTPUTS:"
                    echo "====================="
                    echo "üåê API URL: $API_URL"
                    echo "üé® Frontend URL: $FRONTEND_URL"
                    echo "üì¶ S3 Bucket: $S3_BUCKET"
                    echo ""
                    
                    # Validate critical outputs
                    if [ "$API_URL" = "not_available" ] || [ "$API_URL" = "null" ]; then
                        echo "‚ö†Ô∏è Warning: API URL not available in deployment outputs"
                    fi
                    
                    # Determine handler used
                    HANDLER_USED=$([ "$API_SYNC_DETECTED" = "true" ] && echo "integrated_api_handler" || echo "enhanced_api_handler")
                    
                    # Create comprehensive deployment summary
                    echo "Creating deployment summary..."
                    cat > deployment-summary.json << 'EOF'
{
  "deployment_successful": true,
  "deployment_type": "'$DEPLOYMENT_TYPE'",
  "api_sync_detected": "'$API_SYNC_DETECTED'",
  "timestamp": "'$TIMESTAMP'",
  "execution_mode": "'$EXECUTION_MODE'",
  "trigger_type": "'$TRIGGER_TYPE'",
  "branch_name": "'$BRANCH_NAME'",
  "deployment_duration": "'${DEPLOYMENT_DURATION}s'",
  "outputs": {
    "api_url": "'$API_URL'",
    "frontend_url": "'$FRONTEND_URL'",
    "s3_bucket": "'$S3_BUCKET'"
  },
  "handler_used": "'$HANDLER_USED'",
  "infrastructure_changes": "deployed",
  "stack_status": "deployed",
  "compatibility_mode": false,
  "deployment_metadata": {
    "cdk_version": "2.80.0",
    "deployment_start": "'$DEPLOYMENT_START'",
    "deployment_end": "'$DEPLOYMENT_END'",
    "aws_region": "'${AWS_DEFAULT_REGION:-us-east-1}'"
  }
}
EOF
                    
                    echo "‚úÖ Deployment summary created"
                    echo ""
                    echo "üìä Stage Completion Summary (Deployment Mode):"
                    echo "  Stage: DeployInfrastructure"
                    echo "  Status: COMPLETED (infrastructure deployed)"
                    echo "  Execution Mode: $EXECUTION_MODE"
                    echo "  Infrastructure Changes: Applied to live environment"
                    echo "  Deployment Duration: ${DEPLOYMENT_DURATION}s"
                    echo "  Next Stage: PostDeploymentTests (will execute)"
                    echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
                    echo ""
                    echo "üìä Final Deployment Summary:"
                    cat deployment-summary.json | jq '.' 2>/dev/null || cat deployment-summary.json
                    echo ""
                    echo "üéâ Infrastructure deployment completed successfully!"
                    
                else
                    echo "‚ùå Deployment outputs file not found"
                    echo "üîç Checking for CDK deployment issues..."
                    
                    # Create error summary
                    cat > deployment-summary.json << 'EOF'
{
  "deployment_successful": false,
  "deployment_type": "'$DEPLOYMENT_TYPE'",
  "api_sync_detected": "'$API_SYNC_DETECTED'",
  "timestamp": "'$TIMESTAMP'",
  "execution_mode": "'$EXECUTION_MODE'",
  "trigger_type": "'$TRIGGER_TYPE'",
  "branch_name": "'$BRANCH_NAME'",
  "error": "Deployment outputs not available",
  "outputs": {
    "api_url": "deployment_failed",
    "frontend_url": "deployment_failed",
    "s3_bucket": "deployment_failed"
  },
  "handler_used": "deployment_failed",
  "infrastructure_changes": "failed",
  "stack_status": "failed"
}
EOF
                    
                    echo "‚ùå Deployment failed - outputs not available"
                    exit 1
                fi
            else
                echo "‚ùå CDK deployment failed"
                echo "üîç Deployment error details:"
                tail -20 deployment.log 2>/dev/null || echo "No deployment log available"
                
                # Create failure summary
                cat > deployment-summary.json << 'EOF'
{
  "deployment_successful": false,
  "deployment_type": "'$DEPLOYMENT_TYPE'",
  "api_sync_detected": "'$API_SYNC_DETECTED'",
  "timestamp": "'$TIMESTAMP'",
  "execution_mode": "'$EXECUTION_MODE'",
  "trigger_type": "'$TRIGGER_TYPE'",
  "branch_name": "'$BRANCH_NAME'",
  "error": "CDK deployment failed",
  "outputs": {
    "api_url": "deployment_failed",
    "frontend_url": "deployment_failed",
    "s3_bucket": "deployment_failed"
  },
  "handler_used": "deployment_failed",
  "infrastructure_changes": "failed",
  "stack_status": "failed"
}
EOF
                
                # Ensure outputs.json exists for downstream compatibility
                echo "{}" > outputs.json
                
                echo "‚ùå Infrastructure deployment failed"
                exit 1
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentSummary
          Files:
            - "deployment-summary.json"
            - "outputs.json"
            - "deployment.log"

  PostDeploymentTests:
    Identifier: aws/build@v1
    DependsOn:
      - DeployInfrastructure
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentSummary
    Configuration:
      Steps:
        - Run: |
            echo "üß™ Post-Deployment Testing Stage"
            echo "================================="
            echo "üìÖ Stage Start: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "üè∑Ô∏è Stage: PostDeploymentTests (Conditional Execution)"
            echo ""
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "üìä Stage Execution Context:"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Trigger Type: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            echo "üéØ Stage Decision Logic:"
            if [ "$SKIP_TESTING" = "true" ]; then
                echo "  ‚è≠Ô∏è Testing will be SKIPPED ($EXECUTION_MODE mode)"
                echo "  üìù Reason: $EXECUTION_MODE mode has no live infrastructure to test"
                echo "  üîß Action: Create placeholder test report for downstream compatibility"
                echo "  ‚ö° Benefit: Fast feedback without requiring live environment"
            else
                echo "  ‚úÖ Testing will be EXECUTED ($EXECUTION_MODE mode)"
                echo "  üìù Reason: $EXECUTION_MODE mode has live infrastructure to validate"
                echo "  üîß Action: Run comprehensive post-deployment tests"
                echo "  üß™ Impact: Validate live application functionality"
            fi
            echo ""
            
            # Check if testing should be skipped based on execution mode
            if [ "$SKIP_TESTING" = "true" ]; then
                echo "üìä Stage Execution Decision: SKIP TESTING"
                echo "  Execution mode: $EXECUTION_MODE"
                echo "  Trigger type: $TRIGGER_TYPE"
                echo "  Branch: $BRANCH_NAME"
                echo "  Rationale: No live infrastructure deployed to test"
                echo "  Action: Creating placeholder test report for downstream stages"
                echo ""
                
                # Make artifact handler executable
                chmod +x scripts/artifact-handler.sh
                
                # Create placeholder test report with proper structure
                if ./scripts/artifact-handler.sh create-placeholder testReport "$EXECUTION_MODE" "$TRIGGER_TYPE" "$BRANCH_NAME" "."; then
                    echo "‚úÖ Placeholder test report created successfully"
                else
                    echo "‚ùå Failed to create placeholder test report"
                    exit 1
                fi
                
                # Validate artifact structure
                if ./scripts/artifact-handler.sh validate testReport "."; then
                    echo "‚úÖ Test report artifact structure validation passed"
                else
                    echo "‚ö†Ô∏è Test report artifact structure validation failed - continuing with available artifacts"
                fi
                
                # Test artifact consumption compatibility
                echo "üß™ Testing test report consumption compatibility..."
                if ./scripts/artifact-handler.sh test-consumption testReport "."; then
                    echo "‚úÖ Test report consumption test passed"
                else
                    echo "‚ö†Ô∏è Test report consumption test failed - downstream stages may have issues"
                fi
                
                echo ""
                echo "üìä Stage Completion Summary (Validation Mode):"
                echo "  Stage: PostDeploymentTests"
                echo "  Status: SKIPPED (placeholder artifacts created)"
                echo "  Execution Mode: $EXECUTION_MODE"
                echo "  Testing: None (no live infrastructure to test)"
                echo "  Next Stage: NotifyDeploymentStatus (will execute)"
                echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
                echo ""
                echo "üìÑ Generated test report contents:"
                cat post-deployment-test-report.txt
                
                exit 0
            fi
            
            # Read deployment summary
            if [ -f "deployment-summary.json" ]; then
                API_URL=$(jq -r '.outputs.api_url' deployment-summary.json)
                DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-summary.json)
                HANDLER_USED=$(jq -r '.handler_used' deployment-summary.json)
                
                echo "Testing deployed infrastructure:"
                echo "API URL: $API_URL"
                echo "Deployment type: $DEPLOYMENT_TYPE"
                echo "Handler used: $HANDLER_USED"
            else
                echo "‚ùå Deployment summary not found"
                exit 1
            fi
            
            # Wait for deployment to stabilize
            echo "‚è≥ Waiting for deployment to stabilize..."
            sleep 30
            
            # Test function
            test_endpoint() {
                local endpoint="$1"
                local expected_status="$2"
                local description="$3"
                local method="${4:-GET}"
                local data="${5:-}"
                
                echo "Testing $description..."
                
                if [ "$method" = "POST" ] && [ -n "$data" ]; then
                    response=$(curl -s -w "%{http_code}" -X POST "$API_URL$endpoint" \
                        -H "Content-Type: application/json" \
                        -d "$data" -o response.json)
                else
                    response=$(curl -s -w "%{http_code}" -o response.json "$API_URL$endpoint")
                fi
                
                if [ "$response" = "$expected_status" ]; then
                    echo "‚úÖ $description - OK ($response)"
                    return 0
                else
                    echo "‚ùå $description - FAILED ($response)"
                    echo "Response body:"
                    cat response.json 2>/dev/null || echo "No response body"
                    return 1
                fi
            }
            
            # Run comprehensive API tests
            TESTS_PASSED=true
            
            # Basic health check
            test_endpoint "/health" "200" "Health endpoint" || TESTS_PASSED=false
            
            # People endpoints
            test_endpoint "/people" "200" "People list endpoint" || TESTS_PASSED=false
            
            # Test person creation
            echo "Testing person creation..."
            create_data='{
                "firstName": "Test",
                "lastName": "User",
                "email": "test-deploy@example.com",
                "phone": "+1-555-0199",
                "dateOfBirth": "1990-01-01",
                "address": {
                    "street": "123 Test St",
                    "city": "Test City",
                    "state": "TS",
                    "zipCode": "12345",
                    "country": "USA"
                }
            }'
            
            create_response=$(curl -s -w "%{http_code}" -X POST "$API_URL/people" \
                -H "Content-Type: application/json" \
                -d "$create_data" -o create_response.json)
            
            if [ "$create_response" = "201" ]; then
                echo "‚úÖ Person creation - OK"
                PERSON_ID=$(jq -r '.id' create_response.json 2>/dev/null || echo "")
                
                if [ -n "$PERSON_ID" ] && [ "$PERSON_ID" != "null" ]; then
                    # Test person retrieval
                    test_endpoint "/people/$PERSON_ID" "200" "Person retrieval" || TESTS_PASSED=false
                    
                    # Clean up test person
                    delete_response=$(curl -s -w "%{http_code}" -X DELETE "$API_URL/people/$PERSON_ID" -o /dev/null)
                    if [ "$delete_response" = "204" ]; then
                        echo "‚úÖ Test cleanup - OK"
                    else
                        echo "‚ö†Ô∏è Test cleanup failed ($delete_response)"
                    fi
                fi
            else
                echo "‚ùå Person creation - FAILED ($create_response)"
                cat create_response.json 2>/dev/null || echo "No response body"
                TESTS_PASSED=false
            fi
            
            # Test search endpoint (if available)
            test_endpoint "/people/search" "200" "People search endpoint" || echo "‚ö†Ô∏è Search endpoint not available (non-critical)"
            
            # Generate test report
            # Generate test report
            echo "Post-Deployment Test Report" > post-deployment-test-report.txt
            echo "==========================" >> post-deployment-test-report.txt
            echo "Timestamp: $(date)" >> post-deployment-test-report.txt
            echo "API URL: $API_URL" >> post-deployment-test-report.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> post-deployment-test-report.txt
            echo "Handler Used: $HANDLER_USED" >> post-deployment-test-report.txt
            if [ "$TESTS_PASSED" = true ]; then
                echo "Overall Status: PASSED" >> post-deployment-test-report.txt
            else
                echo "Overall Status: FAILED" >> post-deployment-test-report.txt
            fi
            echo "" >> post-deployment-test-report.txt
            echo "Test Results:" >> post-deployment-test-report.txt
            if test_endpoint "/health" "200" "Health endpoint" >/dev/null 2>&1; then
                echo "- Health endpoint: PASS" >> post-deployment-test-report.txt
            else
                echo "- Health endpoint: FAIL" >> post-deployment-test-report.txt
            fi
            if test_endpoint "/people" "200" "People list endpoint" >/dev/null 2>&1; then
                echo "- People list: PASS" >> post-deployment-test-report.txt
            else
                echo "- People list: FAIL" >> post-deployment-test-report.txt
            fi
            if [ "$create_response" = "201" ]; then
                echo "- Person CRUD: PASS" >> post-deployment-test-report.txt
            else
                echo "- Person CRUD: FAIL" >> post-deployment-test-report.txt
            fi
            echo "" >> post-deployment-test-report.txt
            if [ "$TESTS_PASSED" = true ]; then
                echo "‚úÖ All critical tests passed" >> post-deployment-test-report.txt
            else
                echo "‚ùå Some tests failed" >> post-deployment-test-report.txt
            fi
            
            cat post-deployment-test-report.txt
            
            echo ""
            echo "üìä Stage Completion Summary (Deployment Mode):"
            echo "  Stage: PostDeploymentTests"
            echo "  Status: $([ "$TESTS_PASSED" = true ] && echo "COMPLETED (tests passed)" || echo "COMPLETED (tests failed)")"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Testing: Live infrastructure validated"
            echo "  Test Results: $([ "$TESTS_PASSED" = true ] && echo "PASSED" || echo "FAILED")"
            echo "  Next Stage: NotifyDeploymentStatus (will execute)"
            echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
            echo ""
            
            if [ "$TESTS_PASSED" = true ]; then
                echo "üéâ Post-deployment tests passed!"
                exit 0
            else
                echo "‚ùå Some post-deployment tests failed"
                exit 1
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: testReport
          Files:
            - "post-deployment-test-report.txt"

  NotifyDeploymentStatus:
    Identifier: aws/build@v1
    DependsOn:
      - PostDeploymentTests
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentSummary
        - testReport
    Configuration:
      Steps:
        - Run: |
            echo "üì¢ Deployment Status Notification"
            echo "================================"
            echo "üìÖ Stage Start: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "üè∑Ô∏è Stage: NotifyDeploymentStatus (Always Executes)"
            echo ""
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "üìä Stage Execution Context:"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Trigger Type: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo "  Stage Decision: EXECUTE (NotifyDeploymentStatus always runs with mode-specific notifications)"
            echo "  Stage Purpose: $([ "$EXECUTION_MODE" = "validation" ] && echo "Create validation summary notification" || echo "Create deployment completion notification")"
            echo ""
            
            # Initialize notification variables
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            COMMIT_REF="${CODECATALYST_SOURCE_BRANCH_REF:-unknown}"
            WORKFLOW_NAME="${CODECATALYST_WORKFLOW_NAME:-Infrastructure_Deployment_Pipeline}"
            
            # Make artifact handler executable
            chmod +x scripts/artifact-handler.sh
            
            # Read deployment and test results with graceful handling of placeholder vs real data
            echo "üìã Reading deployment and test results using artifact handler..."
            
            API_URL=$(./scripts/artifact-handler.sh handle-data "deployment-summary.json" ".outputs.api_url" "not_deployed")
            FRONTEND_URL=$(./scripts/artifact-handler.sh handle-data "deployment-summary.json" ".outputs.frontend_url" "not_deployed")
            S3_BUCKET=$(./scripts/artifact-handler.sh handle-data "deployment-summary.json" ".outputs.s3_bucket" "not_deployed")
            DEPLOYMENT_TYPE=$(./scripts/artifact-handler.sh handle-data "deployment-summary.json" ".deployment_type" "unknown")
            HANDLER_USED=$(./scripts/artifact-handler.sh handle-data "deployment-summary.json" ".handler_used" "unknown")
            EXECUTION_MODE_FROM_SUMMARY=$(./scripts/artifact-handler.sh handle-data "deployment-summary.json" ".execution_mode" "$EXECUTION_MODE")
            TRIGGER_TYPE_FROM_SUMMARY=$(./scripts/artifact-handler.sh handle-data "deployment-summary.json" ".trigger_type" "$TRIGGER_TYPE")
            DEPLOYMENT_STATUS=$(./scripts/artifact-handler.sh handle-data "deployment-summary.json" ".deployment_successful" "unknown")
            
            # Check if deployment summary is placeholder
            if ./scripts/artifact-handler.sh is-placeholder "deployment-summary.json"; then
                echo "üìã Placeholder deployment summary detected - using validation mode data"
                DEPLOYMENT_STATUS="validation_placeholder"
            fi
            
            # Read test results with graceful handling
            TEST_STATUS="unknown"
            if [ -f "post-deployment-test-report.txt" ]; then
                echo "üìã Reading test report..."
                if ./scripts/artifact-handler.sh is-placeholder "post-deployment-test-report.txt"; then
                    echo "üìã Placeholder test report detected"
                    TEST_STATUS="skipped"
                elif grep -q "All tests passed" post-deployment-test-report.txt; then
                    TEST_STATUS="passed"
                elif grep -q "Some tests failed" post-deployment-test-report.txt; then
                    TEST_STATUS="failed"
                else
                    TEST_STATUS="completed"
                fi
            else
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    TEST_STATUS="skipped"
                else
                    TEST_STATUS="not_available"
                fi
            fi
            
            # Create mode-specific notification using artifact handler
            echo "üîß Using artifact handler to create notification artifacts..."
            
            # Create placeholder notification with proper structure
            if ./scripts/artifact-handler.sh create-placeholder deploymentNotification "$EXECUTION_MODE" "$TRIGGER_TYPE" "$BRANCH_NAME" "."; then
                echo "‚úÖ Notification artifacts created successfully"
            else
                echo "‚ùå Failed to create notification artifacts"
                exit 1
            fi
            
            # For deployment mode, update notification with real data
            if [ "$EXECUTION_MODE" = "deployment" ]; then
                echo "üîß Updating notification with deployment-specific data..."
                
                # Create deployment-specific notification
                cat > deployment-notification.txt << EOF
üöÄ Infrastructure Deployment Completed
=====================================

‚úÖ Deployment completed successfully!

üìä Deployment Context:
  Timestamp: $TIMESTAMP
  Trigger: $TRIGGER_TYPE
  Branch: $BRANCH_NAME
  Commit: $COMMIT_REF
  Workflow: $WORKFLOW_NAME
  Deployment Type: $DEPLOYMENT_TYPE
  Handler Used: $HANDLER_USED

üèóÔ∏è Deployed Resources:
$([ "$API_URL" != "not_deployed" ] && echo "  üåê API Gateway: $API_URL" || echo "  üåê API Gateway: Deployment information not available")
$([ "$FRONTEND_URL" != "not_deployed" ] && echo "  üé® Frontend (CloudFront): $FRONTEND_URL" || echo "  üé® Frontend (CloudFront): Deployment information not available")
$([ "$S3_BUCKET" != "not_deployed" ] && echo "  üì¶ S3 Bucket: $S3_BUCKET" || echo "  üì¶ S3 Bucket: Deployment information not available")

üîß Integration Status:
$([ "$DEPLOYMENT_TYPE" = "api_sync" ] && echo "  ‚úÖ Registry-API code successfully integrated and deployed" || echo "  ‚ÑπÔ∏è Using existing infrastructure handlers")
$([ "$DEPLOYMENT_TYPE" = "api_sync" ] && echo "  üîó Using integrated_api_handler.py with registry-api components" || echo "  üîó Using enhanced_api_handler.py (infrastructure default)")

üß™ Testing Status:
$(case "$TEST_STATUS" in
    "passed") echo "  ‚úÖ Post-deployment tests: All tests passed" ;;
    "failed") echo "  ‚ùå Post-deployment tests: Some tests failed - review test report" ;;
    "completed") echo "  ‚úÖ Post-deployment tests: Completed - review test report for details" ;;
    "not_available") echo "  ‚ö†Ô∏è Post-deployment tests: Test report not available" ;;
    *) echo "  ‚ùì Post-deployment tests: Status unknown" ;;
esac)

‚úÖ Next Steps:
  1. Verify API endpoints are responding correctly
  2. Update frontend configuration if needed
  3. Monitor application performance and CloudWatch logs
  4. Coordinate with registry-api team for any integration issues
$([ "$TEST_STATUS" = "failed" ] && echo "  5. ‚ö†Ô∏è Review and address failed test cases")

üéâ Infrastructure deployment successful! ‚úÖ
EOF
                
                # Update notification-data.json with real deployment data
                cat > notification-data.json << 'EOF'
{
  "timestamp": "'$TIMESTAMP'",
  "execution_mode": "'$EXECUTION_MODE'",
  "trigger_type": "'$TRIGGER_TYPE'",
  "branch_name": "'$BRANCH_NAME'",
  "commit_ref": "'$COMMIT_REF'",
  "workflow_name": "'$WORKFLOW_NAME'",
  "deployment_type": "'$DEPLOYMENT_TYPE'",
  "handler_used": "'$HANDLER_USED'",
  "deployment_status": "'$DEPLOYMENT_STATUS'",
  "test_status": "'$TEST_STATUS'",
  "resources": {
    "api_url": "'$API_URL'",
    "frontend_url": "'$FRONTEND_URL'",
    "s3_bucket": "'$S3_BUCKET'"
  },
  "stages_executed": [
    "CheckAPISync",
    "PrepareAPIIntegration", 
    "ValidateInfrastructure",
    "DeployInfrastructure",
    "PostDeploymentTests"
  ],
  "stages_skipped": [],
  "notification_type": "deployment_completion",
  "placeholder_artifact": false
}
EOF
            fi
            
            # Validate notification artifact structure
            if ./scripts/artifact-handler.sh validate deploymentNotification "."; then
                echo "‚úÖ Notification artifact structure validation passed"
            else
                echo "‚ö†Ô∏è Notification artifact structure validation failed - continuing with available artifacts"
            fi
            
            # Test notification consumption compatibility
            echo "üß™ Testing notification consumption compatibility..."
            if ./scripts/artifact-handler.sh test-consumption deploymentNotification "."; then
                echo "‚úÖ Notification consumption test passed"
            else
                echo "‚ö†Ô∏è Notification consumption test failed - external systems may have issues"
            fi
            
            # Display the notification
            echo ""
            echo "üìã Generated Notification:"
            echo "========================="
            cat deployment-notification.txt
            
            echo ""
            echo "üìã Structured notification data:"
            cat notification-data.json | jq '.' 2>/dev/null || cat notification-data.json
            
            # Store notification for potential external integrations
            echo ""
            echo "üíæ Storing notification artifacts..."
            echo "‚úÖ Notification artifacts created successfully"
            
            # Future enhancement: This could be extended to send notifications to:
            # - Slack channels
            # - Email recipients  
            # - Microsoft Teams
            # - Custom webhooks
            # - AWS SNS topics
            
            echo ""
            echo "üìä Stage Completion Summary:"
            echo "  Stage: NotifyDeploymentStatus"
            echo "  Status: COMPLETED"
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Notification Type: $([ "$EXECUTION_MODE" = "validation" ] && echo "Validation Summary" || echo "Deployment Completion")"
            echo "  Workflow Status: $([ "$EXECUTION_MODE" = "validation" ] && echo "Validation completed" || echo "Deployment completed")"
            echo "  Duration: $(date -u +%Y-%m-%dT%H:%M:%SZ) (end time)"
            echo ""
            
            echo "üéØ WORKFLOW COMPLETION SUMMARY:"
            echo "==============================="
            echo "  Execution Mode: $EXECUTION_MODE"
            echo "  Trigger Type: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Stages Executed: $([ "$EXECUTION_MODE" = "validation" ] && echo "CheckAPISync, PrepareAPIIntegration, ValidateInfrastructure, NotifyDeploymentStatus" || echo "All stages")"
            echo "  Stages Skipped: $([ "$EXECUTION_MODE" = "validation" ] && echo "DeployInfrastructure (placeholder), PostDeploymentTests (placeholder)" || echo "None")"
            echo "  Infrastructure Changes: $([ "$EXECUTION_MODE" = "validation" ] && echo "None (validation mode)" || echo "Applied to live environment")"
            echo "  Outcome: $([ "$EXECUTION_MODE" = "validation" ] && echo "Pull request validation feedback provided" || echo "Live application deployed and tested")"
            echo ""
            
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "‚úÖ Validation notification completed successfully"
                echo "üîç Pull request validation workflow completed - ready for code review"
            else
                echo "‚úÖ Deployment notification completed successfully"
                echo "üöÄ Full deployment workflow completed - application is live"
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentNotification
          Files:
            - "deployment-notification.txt"
            - "notification-data.json"