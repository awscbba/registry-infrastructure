Name: Infrastructure_Deployment_Pipeline
SchemaVersion: "1.0"

Triggers:
  - Type: PUSH
    Branches:
      - main
  - Type: PULLREQUEST
    Branches:
      - main
    Events:
      - PULLREQUEST_CREATED
      - PULLREQUEST_REVISION_CREATED
  - Type: MANUAL

Actions:
  CheckAPISync:
    Identifier: aws/build@v1
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
    Configuration:
      Steps:
        - Run: |
            echo "üîç Checking API Code Synchronization"
            echo "==================================="
            
            # Execute execution mode detection
            echo "üéØ Detecting execution mode..."
            chmod +x scripts/execution-mode-detection.sh
            ./scripts/execution-mode-detection.sh
            
            # Source the execution mode environment variables
            source execution-mode-env.sh
            
            echo ""
            echo "üìä Execution Mode: $EXECUTION_MODE"
            echo "üîÑ Trigger Type: $TRIGGER_TYPE"
            echo "üåø Branch: $BRANCH_NAME"
            echo ""
            
            # Check if this deployment was triggered by API sync
            if [ -f "lambda/main.py" ] && [ -d "lambda/src" ]; then
                echo "‚úÖ API code synchronized from registry-api repository"
                echo "üìä API sync detected:"
                echo "  - main.py: $([ -f "lambda/main.py" ] && echo "Present" || echo "Missing")"
                echo "  - src/ directory: $([ -d "lambda/src" ] && echo "Present" || echo "Missing")"
                echo "  - requirements.txt: $([ -f "lambda/requirements.txt" ] && echo "Present" || echo "Missing")"
                
                # Check for sync metadata
                if [ -f "lambda/sync-metadata.json" ]; then
                    echo "üìã Sync metadata found:"
                    cat lambda/sync-metadata.json
                fi
                
                echo "üîÑ Proceeding with infrastructure deployment using synchronized API code"
            else
                echo "‚ÑπÔ∏è No API sync detected - using existing lambda handlers"
                echo "üìä Current lambda structure:"
                ls -la lambda/ || echo "Lambda directory not found"
            fi
            
            # Create deployment context
            DEPLOYMENT_TYPE=$([ -f "lambda/main.py" ] && echo "api_sync" || echo "infrastructure_only")
            API_SYNC_DETECTED=$([ -f "lambda/main.py" ] && echo "true" || echo "false")
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            BRANCH=${CODECATALYST_SOURCE_BRANCH_NAME:-main}
            COMMIT=${CODECATALYST_SOURCE_BRANCH_REF:-unknown}
            
            # Merge execution context with deployment context
            echo "{" > deployment-context.json
            echo "  \"deployment_type\": \"$DEPLOYMENT_TYPE\"," >> deployment-context.json
            echo "  \"timestamp\": \"$TIMESTAMP\"," >> deployment-context.json
            echo "  \"branch\": \"$BRANCH\"," >> deployment-context.json
            echo "  \"commit\": \"$COMMIT\"," >> deployment-context.json
            echo "  \"api_sync_detected\": $API_SYNC_DETECTED," >> deployment-context.json
            echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> deployment-context.json
            echo "  \"trigger_type\": \"$TRIGGER_TYPE\"," >> deployment-context.json
            echo "  \"is_main_branch\": $IS_MAIN_BRANCH," >> deployment-context.json
            echo "  \"skip_deployment\": $SKIP_DEPLOYMENT," >> deployment-context.json
            echo "  \"skip_testing\": $SKIP_TESTING" >> deployment-context.json
            echo "}" >> deployment-context.json
            
            cat deployment-context.json
            echo "‚úÖ API sync check completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentContext
          Files:
            - "deployment-context.json"
            - "execution-context.json"
            - "execution-mode-env.sh"

  PrepareAPIIntegration:
    Identifier: aws/build@v1
    DependsOn:
      - CheckAPISync
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
    Configuration:
      Steps:
        - Run: |
            echo "üîß Preparing API Integration"
            echo "==========================="
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            # Read deployment context
            DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-context.json)
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            
            echo "üìä Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            echo "Deployment type: $DEPLOYMENT_TYPE"
            echo "API sync detected: $API_SYNC_DETECTED"
            
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "üîÑ Integrating synchronized API code with infrastructure"
                
                # Create integrated Lambda handler that uses the new API structure
                echo "Creating integrated API handler..."
                mkdir -p lambda
                
                # Create a basic integrated handler file
                echo "# Integrated API Handler - Bridges registry-api code with Lambda infrastructure" > lambda/integrated_api_handler.py
                echo "import json" >> lambda/integrated_api_handler.py
                echo "import logging" >> lambda/integrated_api_handler.py
                echo "import os" >> lambda/integrated_api_handler.py
                echo "import sys" >> lambda/integrated_api_handler.py
                echo "from typing import Dict, Any" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "# Add the src directory to Python path for registry-api imports" >> lambda/integrated_api_handler.py
                echo "sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "# Configure logging" >> lambda/integrated_api_handler.py
                echo "logging.basicConfig(level=logging.INFO)" >> lambda/integrated_api_handler.py
                echo "logger = logging.getLogger(__name__)" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:" >> lambda/integrated_api_handler.py
                echo "    try:" >> lambda/integrated_api_handler.py
                echo "        logger.info(f'Received event: {json.dumps(event, default=str)}')" >> lambda/integrated_api_handler.py
                echo "        try:" >> lambda/integrated_api_handler.py
                echo "            from main import app" >> lambda/integrated_api_handler.py
                echo "            from mangum import Mangum" >> lambda/integrated_api_handler.py
                echo "            handler = Mangum(app, lifespan='off')" >> lambda/integrated_api_handler.py
                echo "            response = handler(event, context)" >> lambda/integrated_api_handler.py
                echo "            logger.info(f'Response status: {response.get(\"statusCode\", \"unknown\")}')" >> lambda/integrated_api_handler.py
                echo "            return response" >> lambda/integrated_api_handler.py
                echo "        except ImportError as e:" >> lambda/integrated_api_handler.py
                echo "            logger.error(f'Failed to import registry-api components: {str(e)}')" >> lambda/integrated_api_handler.py
                echo "            try:" >> lambda/integrated_api_handler.py
                echo "                from enhanced_api_handler import lambda_handler as fallback_handler" >> lambda/integrated_api_handler.py
                echo "                logger.info('Using fallback enhanced_api_handler')" >> lambda/integrated_api_handler.py
                echo "                return fallback_handler(event, context)" >> lambda/integrated_api_handler.py
                echo "            except ImportError:" >> lambda/integrated_api_handler.py
                echo "                return {'statusCode': 500, 'body': json.dumps({'error': 'API handler not available'})}" >> lambda/integrated_api_handler.py
                echo "    except Exception as e:" >> lambda/integrated_api_handler.py
                echo "        logger.error(f'Lambda handler error: {str(e)}', exc_info=True)" >> lambda/integrated_api_handler.py
                echo "        return {'statusCode': 500, 'body': json.dumps({'error': 'Internal Server Error'})}" >> lambda/integrated_api_handler.py
                
                # Update requirements.txt to include registry-api dependencies
                if [ -f "lambda/requirements.txt" ]; then
                    echo "üì¶ Merging requirements from registry-api"
                    
                    # Create merged requirements
                    # Create merged requirements file
                    echo "# Infrastructure requirements (existing)" > lambda/requirements_merged.txt
                    echo "boto3==1.34.144" >> lambda/requirements_merged.txt
                    echo "botocore==1.34.144" >> lambda/requirements_merged.txt
                    echo "pydantic==2.10.3" >> lambda/requirements_merged.txt
                    echo "bcrypt==4.1.3" >> lambda/requirements_merged.txt
                    echo "pyjwt==2.8.0" >> lambda/requirements_merged.txt
                    echo "python-json-logger==2.0.7" >> lambda/requirements_merged.txt
                    echo "" >> lambda/requirements_merged.txt
                    echo "# Registry-API requirements (synchronized)" >> lambda/requirements_merged.txt
                    echo "fastapi==0.111.0" >> lambda/requirements_merged.txt
                    echo "mangum==0.17.0" >> lambda/requirements_merged.txt
                    echo "python-multipart>=0.0.7" >> lambda/requirements_merged.txt
                    echo "pytest==8.2.2" >> lambda/requirements_merged.txt
                    echo "pytest-mock==3.14.0" >> lambda/requirements_merged.txt
                    echo "moto==5.0.9" >> lambda/requirements_merged.txt
                    
                    # Replace original requirements
                    mv lambda/requirements_merged.txt lambda/requirements.txt
                    
                    echo "‚úÖ Requirements merged successfully"
                else
                    echo "‚ö†Ô∏è No requirements.txt found in lambda directory"
                fi
                
                echo "‚úÖ API integration prepared successfully"
            else
                echo "‚ÑπÔ∏è No API sync detected - using existing infrastructure handlers"
            fi
            
            # Create integration summary
            # Create integration summary
            echo "API Integration Summary" > api-integration-summary.txt
            echo "======================" >> api-integration-summary.txt
            echo "Timestamp: $(date)" >> api-integration-summary.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> api-integration-summary.txt
            echo "API Sync Detected: $API_SYNC_DETECTED" >> api-integration-summary.txt
            echo "" >> api-integration-summary.txt
            echo "Integration Actions:" >> api-integration-summary.txt
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "‚úÖ Created integrated_api_handler.py" >> api-integration-summary.txt
                echo "‚úÖ Merged requirements.txt" >> api-integration-summary.txt
            else
                echo "‚ÑπÔ∏è No integration needed" >> api-integration-summary.txt
                echo "‚ÑπÔ∏è Using existing requirements" >> api-integration-summary.txt
            fi
            echo "" >> api-integration-summary.txt
            echo "Handler Priority:" >> api-integration-summary.txt
            echo "1. integrated_api_handler.py (if API sync detected)" >> api-integration-summary.txt
            echo "2. enhanced_api_handler.py (fallback)" >> api-integration-summary.txt
            echo "3. api_handler.py (legacy fallback)" >> api-integration-summary.txt
            
            cat api-integration-summary.txt
            echo "‚úÖ API integration preparation completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: apiIntegration
          Files:
            - "api-integration-summary.txt"
            - "lambda/integrated_api_handler.py"

  ValidateInfrastructure:
    Identifier: aws/build@v1
    DependsOn:
      - PrepareAPIIntegration
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
        - apiIntegration
    Configuration:
      Steps:
        - Run: |
            echo "üîç Enhanced Infrastructure Validation"
            echo "===================================="
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "üìä Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            # Initialize validation results
            VALIDATION_ERRORS=0
            VALIDATION_WARNINGS=0
            VALIDATION_REPORT="validation-report.txt"
            
            echo "Infrastructure Validation Report" > $VALIDATION_REPORT
            echo "===============================" >> $VALIDATION_REPORT
            echo "Timestamp: $(date)" >> $VALIDATION_REPORT
            echo "Execution Mode: $EXECUTION_MODE" >> $VALIDATION_REPORT
            echo "Trigger Type: $TRIGGER_TYPE" >> $VALIDATION_REPORT
            echo "Branch: $BRANCH_NAME" >> $VALIDATION_REPORT
            echo "" >> $VALIDATION_REPORT
            
            # Install required tools
            echo "üì¶ Installing required tools..."
            curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin
            
            # Environment info
            echo "Environment Information:"
            echo "Node version: $(node --version)"
            echo "npm version: $(npm --version)"
            echo "Python version: $(python3 --version)"
            echo "Just version: $(just --version)"
            
            # Function to log validation results
            log_validation() {
                local level="$1"
                local message="$2"
                local suggestion="${3:-}"
                
                echo "[$level] $message" | tee -a $VALIDATION_REPORT
                if [ -n "$suggestion" ]; then
                    echo "  üí° Suggestion: $suggestion" | tee -a $VALIDATION_REPORT
                fi
                
                if [ "$level" = "ERROR" ]; then
                    VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
                elif [ "$level" = "WARNING" ]; then
                    VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
                fi
            }
            
            # 1. AWS Credentials Validation
            echo ""
            echo "üîê Step 1: AWS Credentials Validation"
            echo "====================================="
            
            if aws sts get-caller-identity > aws-identity.json 2>&1; then
                ACCOUNT_ID=$(jq -r '.Account' aws-identity.json)
                USER_ARN=$(jq -r '.Arn' aws-identity.json)
                echo "‚úÖ AWS credentials are valid"
                echo "  Account ID: $ACCOUNT_ID"
                echo "  User/Role: $USER_ARN"
                log_validation "INFO" "AWS credentials validated successfully"
                log_validation "INFO" "Account ID: $ACCOUNT_ID"
                log_validation "INFO" "User/Role: $USER_ARN"
            else
                echo "‚ùå AWS credentials are invalid"
                log_validation "ERROR" "AWS credentials validation failed" "Check your AWS credentials and permissions"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            fi
            
            # 2. IAM Permission Validation
            echo ""
            echo "üîë Step 2: IAM Permission Validation"
            echo "===================================="
            
            echo "Testing required IAM permissions..."
            
            # Test DynamoDB permissions
            if aws dynamodb describe-limits --region us-east-1 >/dev/null 2>&1; then
                echo "  ‚úÖ DynamoDB permissions: OK"
                log_validation "INFO" "DynamoDB permissions validated"
            else
                echo "  ‚ùå DynamoDB permissions: FAILED"
                log_validation "ERROR" "DynamoDB permissions insufficient" "Ensure your role has DynamoDB read/write permissions"
            fi
            
            # Test Lambda permissions
            if aws lambda list-functions --max-items 1 >/dev/null 2>&1; then
                echo "  ‚úÖ Lambda permissions: OK"
                log_validation "INFO" "Lambda permissions validated"
            else
                echo "  ‚ùå Lambda permissions: FAILED"
                log_validation "ERROR" "Lambda permissions insufficient" "Ensure your role has Lambda create/update permissions"
            fi
            
            # Test S3 permissions
            if aws s3api list-buckets >/dev/null 2>&1; then
                echo "  ‚úÖ S3 permissions: OK"
                log_validation "INFO" "S3 permissions validated"
            else
                echo "  ‚ùå S3 permissions: FAILED"
                log_validation "ERROR" "S3 permissions insufficient" "Ensure your role has S3 bucket management permissions"
            fi
            
            # Test IAM permissions
            if aws iam get-user >/dev/null 2>&1 || aws iam get-role --role-name CodeCatalystWorkflowDevelopmentRole-AWSCocha >/dev/null 2>&1; then
                echo "  ‚úÖ IAM permissions: OK"
                log_validation "INFO" "IAM permissions validated"
            else
                echo "  ‚ö†Ô∏è IAM permissions: LIMITED"
                log_validation "WARNING" "IAM permissions may be limited" "This might affect role creation during deployment"
            fi
            
            # 3. Resource Configuration Validation
            echo ""
            echo "üèóÔ∏è Step 3: Resource Configuration Validation"
            echo "==========================================="
            
            # Validate CDK stack configuration
            if [ -f "people_register_infrastructure/people_register_infrastructure_stack.py" ]; then
                echo "Validating CDK stack configuration..."
                
                # Check for common configuration issues
                if grep -q "PYTHON_3_11" people_register_infrastructure/people_register_infrastructure_stack.py; then
                    echo "  ‚ö†Ô∏è Found PYTHON_3_11 runtime - will be updated to PYTHON_3_9"
                    log_validation "WARNING" "Lambda runtime PYTHON_3_11 detected" "Will be automatically updated to PYTHON_3_9 for compatibility"
                fi
                
                # Check for hardcoded values that should be parameterized
                if grep -q "your-jwt-secret-change-in-production" people_register_infrastructure/people_register_infrastructure_stack.py; then
                    echo "  ‚ö†Ô∏è Default JWT secret detected"
                    log_validation "WARNING" "Default JWT secret found in configuration" "Consider using AWS Secrets Manager for production deployments"
                fi
                
                if grep -q "production-csrf-secret-change-this-value" people_register_infrastructure/people_register_infrastructure_stack.py; then
                    echo "  ‚ö†Ô∏è Default CSRF secret detected"
                    log_validation "WARNING" "Default CSRF secret found in configuration" "Consider using AWS Secrets Manager for production deployments"
                fi
                
                # Check for proper removal policies
                if grep -q "RemovalPolicy.DESTROY" people_register_infrastructure/people_register_infrastructure_stack.py; then
                    echo "  ‚ÑπÔ∏è DESTROY removal policy detected (appropriate for development)"
                    log_validation "INFO" "DESTROY removal policy configured for development environment"
                fi
                
                echo "  ‚úÖ CDK stack configuration validated"
                log_validation "INFO" "CDK stack configuration file validated"
            else
                echo "  ‚ùå CDK stack file not found"
                log_validation "ERROR" "CDK stack configuration file missing" "Ensure people_register_infrastructure_stack.py exists"
            fi
            
            # Validate Lambda handler files
            echo "Validating Lambda handler configuration..."
            LAMBDA_HANDLERS=("enhanced_api_handler.py" "auth_handler.py")
            
            for handler in "${LAMBDA_HANDLERS[@]}"; do
                if [ -f "lambda/$handler" ]; then
                    echo "  ‚úÖ Found $handler"
                    log_validation "INFO" "Lambda handler $handler found"
                    
                    # Basic syntax check
                    if python3 -m py_compile "lambda/$handler" 2>/dev/null; then
                        echo "    ‚úÖ Syntax validation passed"
                        log_validation "INFO" "Lambda handler $handler syntax validated"
                    else
                        echo "    ‚ùå Syntax validation failed"
                        log_validation "ERROR" "Lambda handler $handler has syntax errors" "Review Python syntax in $handler"
                    fi
                else
                    echo "  ‚ùå $handler not found"
                    log_validation "ERROR" "Required Lambda handler $handler missing" "Ensure $handler exists in lambda/ directory"
                fi
            done
            
            # Check for integrated handler (created during API integration)
            if [ -f "lambda/integrated_api_handler.py" ]; then
                echo "  ‚úÖ Found integrated_api_handler.py"
                log_validation "INFO" "Integrated API handler found"
            else
                echo "  ‚ÑπÔ∏è integrated_api_handler.py not found (will be created if API sync detected)"
                log_validation "INFO" "Integrated API handler will be created during API integration if needed"
            fi
            
            # Validate requirements.txt
            if [ -f "lambda/requirements.txt" ]; then
                echo "  ‚úÖ Lambda requirements.txt found"
                log_validation "INFO" "Lambda requirements.txt validated"
                
                # Check for potential dependency conflicts
                if grep -q "boto3" lambda/requirements.txt && grep -q "botocore" lambda/requirements.txt; then
                    echo "    ‚ÑπÔ∏è boto3 and botocore versions should be compatible"
                    log_validation "INFO" "boto3 and botocore dependencies found - ensure version compatibility"
                fi
            else
                echo "  ‚ùå Lambda requirements.txt not found"
                log_validation "ERROR" "Lambda requirements.txt missing" "Create requirements.txt with necessary Python dependencies"
            fi
            
            # 4. CDK Synthesis Validation (Enhanced)
            echo ""
            echo "‚öôÔ∏è Step 4: CDK Synthesis Validation"
            echo "=================================="
            
            # Fix Lambda runtime compatibility
            echo "üîß Applying runtime compatibility fixes..."
            if [ -f "people_register_infrastructure/people_register_infrastructure_stack.py" ]; then
                cp people_register_infrastructure/people_register_infrastructure_stack.py people_register_infrastructure/people_register_infrastructure_stack.py.backup
                sed -i 's/runtime=_lambda\.Runtime\.PYTHON_3_11/runtime=_lambda.Runtime.PYTHON_3_9/g' people_register_infrastructure/people_register_infrastructure_stack.py
                echo "‚úÖ Updated Lambda runtime from PYTHON_3_11 to PYTHON_3_9"
                log_validation "INFO" "Lambda runtime updated to PYTHON_3_9 for compatibility"
            fi
            
            # Update CDK stack to use integrated handler if API sync detected
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "üîß Updating CDK stack to use integrated API handler..."
                
                # Update the handler reference in the CDK stack
                if [ -f "people_register_infrastructure/people_register_infrastructure_stack.py" ]; then
                    sed -i 's/handler="enhanced_api_handler.lambda_handler"/handler="integrated_api_handler.lambda_handler"/g' people_register_infrastructure/people_register_infrastructure_stack.py
                    echo "‚úÖ Updated CDK stack to use integrated_api_handler"
                    log_validation "INFO" "CDK stack updated to use integrated API handler"
                fi
            fi
            
            # Python environment setup
            echo "üîÑ Setting up Python environment..."
            python3 -m venv .venv
            source .venv/bin/activate
            
            # Install compatible CDK dependencies
            echo "üîÑ Installing compatible Python CDK dependencies..."
            if pip install aws-cdk-lib==2.80.0 constructs>=10.0.0,\<11.0.0 boto3>=1.34.0 pydantic>=2.7.0; then
                echo "‚úÖ CDK Python dependencies installed"
                log_validation "INFO" "CDK Python dependencies installed successfully"
            else
                echo "‚ùå Failed to install CDK Python dependencies"
                log_validation "ERROR" "CDK Python dependencies installation failed" "Check pip and Python environment setup"
            fi
            
            # Install compatible CDK CLI
            echo "üîÑ Installing compatible CDK CLI..."
            npm uninstall -g aws-cdk 2>/dev/null || echo "No existing CDK to uninstall"
            if npm install -g aws-cdk@2.80.0; then
                echo "‚úÖ CDK CLI installed"
                log_validation "INFO" "CDK CLI v2.80.0 installed successfully"
            else
                echo "‚ùå Failed to install CDK CLI"
                log_validation "ERROR" "CDK CLI installation failed" "Check npm and Node.js setup"
            fi
            
            # CDK version check
            CDK_VERSION=$(cdk --version 2>/dev/null || echo "unknown")
            echo "CDK version: $CDK_VERSION"
            log_validation "INFO" "CDK version: $CDK_VERSION"
            
            # CDK synthesis validation with detailed error reporting
            echo "üîÑ Performing CDK synthesis validation..."
            if source .venv/bin/activate && cdk synth --quiet > cdk-synth-output.json 2>cdk-synth-errors.txt; then
                echo "‚úÖ CDK synthesis validation - SUCCESS"
                log_validation "INFO" "CDK synthesis completed successfully"
                
                # Analyze synthesized template for potential issues
                if [ -f "cdk.out/PeopleRegisterInfrastructureStack.template.json" ]; then
                    TEMPLATE_SIZE=$(wc -c < "cdk.out/PeopleRegisterInfrastructureStack.template.json")
                    echo "  üìä CloudFormation template size: $TEMPLATE_SIZE bytes"
                    log_validation "INFO" "CloudFormation template generated ($TEMPLATE_SIZE bytes)"
                    
                    # Check for template size limits (CloudFormation has a 51,200 byte limit for direct uploads)
                    if [ $TEMPLATE_SIZE -gt 51200 ]; then
                        echo "  ‚ö†Ô∏è Template size exceeds direct upload limit"
                        log_validation "WARNING" "CloudFormation template size ($TEMPLATE_SIZE bytes) exceeds 51KB limit" "Template will be uploaded to S3 during deployment"
                    fi
                    
                    # Count resources
                    RESOURCE_COUNT=$(jq '.Resources | length' "cdk.out/PeopleRegisterInfrastructureStack.template.json" 2>/dev/null || echo "unknown")
                    echo "  üìä CloudFormation resources: $RESOURCE_COUNT"
                    log_validation "INFO" "CloudFormation template contains $RESOURCE_COUNT resources"
                    
                    # Check for resource limits (CloudFormation has a 500 resource limit)
                    if [ "$RESOURCE_COUNT" != "unknown" ] && [ $RESOURCE_COUNT -gt 400 ]; then
                        echo "  ‚ö†Ô∏è High resource count detected"
                        log_validation "WARNING" "High resource count ($RESOURCE_COUNT) approaching CloudFormation limit" "Consider splitting into multiple stacks if approaching 500 resources"
                    fi
                fi
            else
                echo "‚ùå CDK synthesis validation - FAILED"
                log_validation "ERROR" "CDK synthesis failed" "Review CDK stack configuration and dependencies"
                
                # Provide detailed error analysis
                if [ -f "cdk-synth-errors.txt" ]; then
                    echo "üîç CDK Synthesis Error Details:"
                    echo "==============================="
                    cat cdk-synth-errors.txt
                    
                    # Analyze common error patterns and provide suggestions
                    if grep -q "ModuleNotFoundError" cdk-synth-errors.txt; then
                        log_validation "ERROR" "Python module import error detected" "Check that all required Python packages are installed in the virtual environment"
                    fi
                    
                    if grep -q "ValidationError" cdk-synth-errors.txt; then
                        log_validation "ERROR" "CDK validation error detected" "Review CDK construct configuration and property values"
                    fi
                    
                    if grep -q "Cannot find module" cdk-synth-errors.txt; then
                        log_validation "ERROR" "Node.js module error detected" "Check that CDK CLI and dependencies are properly installed"
                    fi
                    
                    if grep -q "Credentials" cdk-synth-errors.txt; then
                        log_validation "ERROR" "AWS credentials error during synthesis" "Verify AWS credentials and permissions"
                    fi
                fi
                
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            fi
            
            # 5. Generate Validation Summary
            echo ""
            echo "üìã Step 5: Validation Summary"
            echo "============================"
            
            echo "" >> $VALIDATION_REPORT
            echo "VALIDATION SUMMARY" >> $VALIDATION_REPORT
            echo "==================" >> $VALIDATION_REPORT
            echo "Total Errors: $VALIDATION_ERRORS" >> $VALIDATION_REPORT
            echo "Total Warnings: $VALIDATION_WARNINGS" >> $VALIDATION_REPORT
            echo "" >> $VALIDATION_REPORT
            
            if [ $VALIDATION_ERRORS -eq 0 ]; then
                echo "‚úÖ Infrastructure validation completed successfully"
                echo "  Errors: $VALIDATION_ERRORS"
                echo "  Warnings: $VALIDATION_WARNINGS"
                log_validation "INFO" "Infrastructure validation completed successfully"
                
                # Create validation success artifact
                echo "{" > validation-results.json
                echo "  \"status\": \"success\"," >> validation-results.json
                echo "  \"errors\": $VALIDATION_ERRORS," >> validation-results.json
                echo "  \"warnings\": $VALIDATION_WARNINGS," >> validation-results.json
                echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> validation-results.json
                echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> validation-results.json
                echo "  \"cdk_synthesis\": \"success\"," >> validation-results.json
                echo "  \"iam_permissions\": \"validated\"," >> validation-results.json
                echo "  \"resource_configuration\": \"validated\"" >> validation-results.json
                echo "}" >> validation-results.json
            else
                echo "‚ùå Infrastructure validation failed"
                echo "  Errors: $VALIDATION_ERRORS"
                echo "  Warnings: $VALIDATION_WARNINGS"
                echo ""
                echo "üîç Please review the validation report for detailed error information and suggested fixes."
                log_validation "ERROR" "Infrastructure validation failed with $VALIDATION_ERRORS errors"
                
                # Create validation failure artifact
                echo "{" > validation-results.json
                echo "  \"status\": \"failed\"," >> validation-results.json
                echo "  \"errors\": $VALIDATION_ERRORS," >> validation-results.json
                echo "  \"warnings\": $VALIDATION_WARNINGS," >> validation-results.json
                echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> validation-results.json
                echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> validation-results.json
                echo "  \"cdk_synthesis\": \"failed\"," >> validation-results.json
                echo "  \"iam_permissions\": \"checked\"," >> validation-results.json
                echo "  \"resource_configuration\": \"checked\"" >> validation-results.json
                echo "}" >> validation-results.json
                
                # Display validation report
                echo ""
                echo "üìã VALIDATION REPORT:"
                echo "===================="
                cat $VALIDATION_REPORT
                
                exit 1
            fi
            
            echo ""
            echo "üìã Full validation report saved to: $VALIDATION_REPORT"
            echo "üìä Validation results saved to: validation-results.json"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: validationResults
          Files:
            - "validation-report.txt"
            - "validation-results.json"
            - "cdk-synth-output.json"
            - "cdk-synth-errors.txt"

  DeployInfrastructure:
    Identifier: aws/build@v1
    DependsOn:
      - ValidateInfrastructure
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
        - apiIntegration
        - validationResults
    Configuration:
      Steps:
        - Run: |
            echo "üöÄ Infrastructure Deployment Stage"
            echo "================================="
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "üìä Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            # Read deployment context for consistent artifact creation
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected // false' deployment-context.json 2>/dev/null || echo "false")
            DEPLOYMENT_TYPE=$(jq -r '.deployment_type // "infrastructure_only"' deployment-context.json 2>/dev/null || echo "infrastructure_only")
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            
            echo "üìã Deployment Context:"
            echo "  API Sync Detected: $API_SYNC_DETECTED"
            echo "  Deployment Type: $DEPLOYMENT_TYPE"
            echo "  Timestamp: $TIMESTAMP"
            echo ""
            
            # Determine execution mode and create appropriate artifacts
            if [ "$SKIP_DEPLOYMENT" = "true" ]; then
                echo "üîç VALIDATION MODE - Creating placeholder artifacts"
                echo "=================================================="
                echo "‚ÑπÔ∏è Execution mode: $EXECUTION_MODE"
                echo "üîÑ Trigger type: $TRIGGER_TYPE"
                echo "üåø Branch: $BRANCH_NAME"
                echo "‚è≠Ô∏è Skipping actual infrastructure deployment"
                echo ""
                
                # Read validation results to include in placeholder
                VALIDATION_STATUS="unknown"
                if [ -f "validation-results.json" ]; then
                    VALIDATION_STATUS=$(jq -r '.status // "unknown"' validation-results.json 2>/dev/null || echo "unknown")
                    echo "üìä Validation Status: $VALIDATION_STATUS"
                fi
                
                # Create comprehensive placeholder deployment summary
                echo "üìù Creating placeholder deployment summary..."
                cat > deployment-summary.json << EOF
{
  "deployment_successful": false,
  "deployment_type": "validation_placeholder",
  "api_sync_detected": $API_SYNC_DETECTED,
  "timestamp": "$TIMESTAMP",
  "execution_mode": "$EXECUTION_MODE",
  "trigger_type": "$TRIGGER_TYPE",
  "branch_name": "$BRANCH_NAME",
  "skip_reason": "Validation mode - deployment skipped for $TRIGGER_TYPE trigger",
  "validation_status": "$VALIDATION_STATUS",
  "outputs": {
    "api_url": "https://validation-placeholder.example.com/api",
    "frontend_url": "https://validation-placeholder.example.com",
    "s3_bucket": "validation-placeholder-bucket"
  },
  "handler_used": "validation_placeholder",
  "infrastructure_changes": "none",
  "deployment_duration": "0s",
  "resources_created": 0,
  "resources_updated": 0,
  "resources_deleted": 0,
  "stack_status": "validation_only",
  "compatibility_mode": true
}
EOF
                
                # Create placeholder outputs.json with consistent structure
                echo "üìù Creating placeholder outputs..."
                cat > outputs.json << EOF
{
  "PeopleRegisterInfrastructureStack": {
    "ApiUrl": "https://validation-placeholder.example.com/api",
    "FrontendUrl": "https://validation-placeholder.example.com",
    "S3BucketName": "validation-placeholder-bucket",
    "ValidationMode": true,
    "ExecutionMode": "$EXECUTION_MODE",
    "TriggerType": "$TRIGGER_TYPE"
  }
}
EOF
                
                # Create deployment log for consistency
                echo "üìù Creating deployment log..."
                cat > deployment.log << EOF
Infrastructure Deployment Log - Validation Mode
==============================================
Timestamp: $TIMESTAMP
Execution Mode: $EXECUTION_MODE
Trigger Type: $TRIGGER_TYPE
Branch: $BRANCH_NAME

VALIDATION MODE ACTIVE
=====================
- Actual deployment skipped
- Placeholder artifacts created
- Validation status: $VALIDATION_STATUS
- API sync detected: $API_SYNC_DETECTED
- Deployment type: $DEPLOYMENT_TYPE

Placeholder Resources Created:
- API URL: https://validation-placeholder.example.com/api
- Frontend URL: https://validation-placeholder.example.com
- S3 Bucket: validation-placeholder-bucket

Status: Validation mode completed successfully
EOF
                
                echo "‚úÖ Placeholder artifacts created successfully"
                echo "üìä Deployment Summary (Validation Mode):"
                cat deployment-summary.json | jq '.' 2>/dev/null || cat deployment-summary.json
                echo ""
                echo "üéØ Validation mode execution completed - ready for downstream stages"
                exit 0
            fi
            
            echo "üèóÔ∏è DEPLOYMENT MODE - Executing actual infrastructure deployment"
            echo "=============================================================="
            echo "‚úÖ Execution mode: $EXECUTION_MODE"
            echo "üîÑ Trigger type: $TRIGGER_TYPE"
            echo "üåø Branch: $BRANCH_NAME"
            echo "üöÄ Proceeding with actual infrastructure deployment"
            echo ""
            
            # Setup Python environment for deployment
            echo "üîß Setting up deployment environment..."
            python3 -m venv .venv
            source .venv/bin/activate
            
            # Install CDK dependencies with error handling
            echo "üì¶ Installing CDK dependencies..."
            if ! pip install aws-cdk-lib==2.80.0 constructs>=10.0.0,\<11.0.0 boto3>=1.34.0 pydantic>=2.7.0; then
                echo "‚ùå Failed to install Python CDK dependencies"
                exit 1
            fi
            
            # Install CDK CLI with error handling
            echo "üì¶ Installing CDK CLI..."
            npm uninstall -g aws-cdk 2>/dev/null || echo "No existing CDK to uninstall"
            if ! npm install -g aws-cdk@2.80.0; then
                echo "‚ùå Failed to install CDK CLI"
                exit 1
            fi
            
            echo "‚úÖ Deployment environment setup completed"
            echo ""
            
            # Pre-deployment validation
            echo "üîç Pre-deployment validation..."
            if ! aws sts get-caller-identity > /dev/null 2>&1; then
                echo "‚ùå AWS credentials validation failed"
                exit 1
            fi
            echo "‚úÖ AWS credentials validated"
            
            # Start deployment with comprehensive logging
            echo "üèóÔ∏è Starting CDK deployment..."
            echo "Deployment type: $DEPLOYMENT_TYPE"
            echo "API sync detected: $API_SYNC_DETECTED"
            echo "Handler selection: $([ "$API_SYNC_DETECTED" = "true" ] && echo "integrated_api_handler" || echo "enhanced_api_handler")"
            echo ""
            
            # Record deployment start time
            DEPLOYMENT_START=$(date +%s)
            
            # Execute CDK deployment with detailed error handling
            echo "üöÄ Executing CDK deployment..."
            if source .venv/bin/activate && cdk deploy --require-approval never --outputs-file outputs.json 2>&1 | tee deployment.log; then
                DEPLOYMENT_END=$(date +%s)
                DEPLOYMENT_DURATION=$((DEPLOYMENT_END - DEPLOYMENT_START))
                
                echo "‚úÖ CDK deployment completed successfully"
                echo "‚è±Ô∏è Deployment duration: ${DEPLOYMENT_DURATION}s"
                echo ""
                
                # Extract and validate deployment outputs
                echo "üîç Extracting deployment outputs..."
                if [ -f "outputs.json" ]; then
                    # Extract outputs with fallback values
                    API_URL=$(jq -r '.PeopleRegisterInfrastructureStack.ApiUrl // "not_available"' outputs.json 2>/dev/null || echo "not_available")
                    FRONTEND_URL=$(jq -r '.PeopleRegisterInfrastructureStack.FrontendUrl // "not_available"' outputs.json 2>/dev/null || echo "not_available")
                    S3_BUCKET=$(jq -r '.PeopleRegisterInfrastructureStack.S3BucketName // "not_available"' outputs.json 2>/dev/null || echo "not_available")
                    
                    echo "üìä DEPLOYMENT OUTPUTS:"
                    echo "====================="
                    echo "üåê API URL: $API_URL"
                    echo "üé® Frontend URL: $FRONTEND_URL"
                    echo "üì¶ S3 Bucket: $S3_BUCKET"
                    echo ""
                    
                    # Validate critical outputs
                    if [ "$API_URL" = "not_available" ] || [ "$API_URL" = "null" ]; then
                        echo "‚ö†Ô∏è Warning: API URL not available in deployment outputs"
                    fi
                    
                    # Determine handler used
                    HANDLER_USED=$([ "$API_SYNC_DETECTED" = "true" ] && echo "integrated_api_handler" || echo "enhanced_api_handler")
                    
                    # Create comprehensive deployment summary
                    echo "üìù Creating deployment summary..."
                    cat > deployment-summary.json << EOF
{
  "deployment_successful": true,
  "deployment_type": "$DEPLOYMENT_TYPE",
  "api_sync_detected": $API_SYNC_DETECTED,
  "timestamp": "$TIMESTAMP",
  "execution_mode": "$EXECUTION_MODE",
  "trigger_type": "$TRIGGER_TYPE",
  "branch_name": "$BRANCH_NAME",
  "deployment_duration": "${DEPLOYMENT_DURATION}s",
  "outputs": {
    "api_url": "$API_URL",
    "frontend_url": "$FRONTEND_URL",
    "s3_bucket": "$S3_BUCKET"
  },
  "handler_used": "$HANDLER_USED",
  "infrastructure_changes": "deployed",
  "stack_status": "deployed",
  "compatibility_mode": false,
  "deployment_metadata": {
    "cdk_version": "2.80.0",
    "deployment_start": $DEPLOYMENT_START,
    "deployment_end": $DEPLOYMENT_END,
    "aws_region": "${AWS_DEFAULT_REGION:-us-east-1}"
  }
}
EOF
                    
                    echo "‚úÖ Deployment summary created"
                    echo "üìä Final Deployment Summary:"
                    cat deployment-summary.json | jq '.' 2>/dev/null || cat deployment-summary.json
                    echo ""
                    echo "üéâ Infrastructure deployment completed successfully!"
                    
                else
                    echo "‚ùå Deployment outputs file not found"
                    echo "üîç Checking for CDK deployment issues..."
                    
                    # Create error summary
                    cat > deployment-summary.json << EOF
{
  "deployment_successful": false,
  "deployment_type": "$DEPLOYMENT_TYPE",
  "api_sync_detected": $API_SYNC_DETECTED,
  "timestamp": "$TIMESTAMP",
  "execution_mode": "$EXECUTION_MODE",
  "trigger_type": "$TRIGGER_TYPE",
  "branch_name": "$BRANCH_NAME",
  "error": "Deployment outputs not available",
  "outputs": {
    "api_url": "deployment_failed",
    "frontend_url": "deployment_failed",
    "s3_bucket": "deployment_failed"
  },
  "handler_used": "deployment_failed",
  "infrastructure_changes": "failed",
  "stack_status": "failed"
}
EOF
                    
                    echo "‚ùå Deployment failed - outputs not available"
                    exit 1
                fi
            else
                echo "‚ùå CDK deployment failed"
                echo "üîç Deployment error details:"
                tail -20 deployment.log 2>/dev/null || echo "No deployment log available"
                
                # Create failure summary
                cat > deployment-summary.json << EOF
{
  "deployment_successful": false,
  "deployment_type": "$DEPLOYMENT_TYPE",
  "api_sync_detected": $API_SYNC_DETECTED,
  "timestamp": "$TIMESTAMP",
  "execution_mode": "$EXECUTION_MODE",
  "trigger_type": "$TRIGGER_TYPE",
  "branch_name": "$BRANCH_NAME",
  "error": "CDK deployment failed",
  "outputs": {
    "api_url": "deployment_failed",
    "frontend_url": "deployment_failed",
    "s3_bucket": "deployment_failed"
  },
  "handler_used": "deployment_failed",
  "infrastructure_changes": "failed",
  "stack_status": "failed"
}
EOF
                
                # Ensure outputs.json exists for downstream compatibility
                echo "{}" > outputs.json
                
                echo "‚ùå Infrastructure deployment failed"
                exit 1
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentSummary
          Files:
            - "deployment-summary.json"
            - "outputs.json"
            - "deployment.log"

  PostDeploymentTests:
    Identifier: aws/build@v1
    DependsOn:
      - DeployInfrastructure
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentSummary
    Configuration:
      Steps:
        - Run: |
            echo "üß™ Post-Deployment Testing Stage"
            echo "================================="
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "üìä Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            echo "üéØ Stage Decision Logic:"
            if [ "$SKIP_TESTING" = "true" ]; then
                echo "  ‚è≠Ô∏è Testing will be SKIPPED (validation mode)"
                echo "  üìù Placeholder artifacts will be created"
                echo "  üîÑ Reason: $EXECUTION_MODE mode detected"
            else
                echo "  ‚úÖ Testing will be EXECUTED (deployment mode)"
                echo "  üß™ Full post-deployment tests will run"
                echo "  üîÑ Reason: $EXECUTION_MODE mode detected"
            fi
            echo ""
            
            # Check if testing should be skipped based on execution mode
            if [ "$SKIP_TESTING" = "true" ]; then
                echo "‚ÑπÔ∏è Execution mode: $EXECUTION_MODE - skipping post-deployment tests"
                echo "üîÑ Trigger type: $TRIGGER_TYPE"
                echo "üåø Branch: $BRANCH_NAME"
                echo ""
                echo "üìù Creating placeholder test report for downstream compatibility..."
                
                # Create placeholder test report with same structure as actual report
                echo "Post-Deployment Test Report" > post-deployment-test-report.txt
                echo "==========================" >> post-deployment-test-report.txt
                echo "Timestamp: $(date)" >> post-deployment-test-report.txt
                echo "Execution Mode: $EXECUTION_MODE" >> post-deployment-test-report.txt
                echo "Trigger Type: $TRIGGER_TYPE" >> post-deployment-test-report.txt
                echo "Branch: $BRANCH_NAME" >> post-deployment-test-report.txt
                echo "API URL: N/A (validation mode)" >> post-deployment-test-report.txt
                echo "Deployment Type: N/A (validation mode)" >> post-deployment-test-report.txt
                echo "Handler Used: N/A (validation mode)" >> post-deployment-test-report.txt
                echo "Overall Status: SKIPPED" >> post-deployment-test-report.txt
                echo "" >> post-deployment-test-report.txt
                echo "Test Results:" >> post-deployment-test-report.txt
                echo "- Health endpoint: SKIPPED (validation mode)" >> post-deployment-test-report.txt
                echo "- People list: SKIPPED (validation mode)" >> post-deployment-test-report.txt
                echo "- Person CRUD: SKIPPED (validation mode)" >> post-deployment-test-report.txt
                echo "" >> post-deployment-test-report.txt
                echo "‚ÑπÔ∏è Tests skipped for $EXECUTION_MODE mode" >> post-deployment-test-report.txt
                echo "üîÑ Trigger: $TRIGGER_TYPE" >> post-deployment-test-report.txt
                echo "üåø Branch: $BRANCH_NAME" >> post-deployment-test-report.txt
                echo "" >> post-deployment-test-report.txt
                echo "üìã Validation Mode Summary:" >> post-deployment-test-report.txt
                echo "- Post-deployment tests are skipped in validation mode" >> post-deployment-test-report.txt
                echo "- This placeholder report maintains artifact compatibility" >> post-deployment-test-report.txt
                echo "- Actual testing occurs only on main branch deployments" >> post-deployment-test-report.txt
                
                echo "‚úÖ Placeholder test report created successfully"
                echo "üìÑ Report contents:"
                cat post-deployment-test-report.txt
                
                exit 0
            fi
            
            # Read deployment summary
            if [ -f "deployment-summary.json" ]; then
                API_URL=$(jq -r '.outputs.api_url' deployment-summary.json)
                DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-summary.json)
                HANDLER_USED=$(jq -r '.handler_used' deployment-summary.json)
                
                echo "Testing deployed infrastructure:"
                echo "API URL: $API_URL"
                echo "Deployment type: $DEPLOYMENT_TYPE"
                echo "Handler used: $HANDLER_USED"
            else
                echo "‚ùå Deployment summary not found"
                exit 1
            fi
            
            # Wait for deployment to stabilize
            echo "‚è≥ Waiting for deployment to stabilize..."
            sleep 30
            
            # Test function
            test_endpoint() {
                local endpoint="$1"
                local expected_status="$2"
                local description="$3"
                local method="${4:-GET}"
                local data="${5:-}"
                
                echo "Testing $description..."
                
                if [ "$method" = "POST" ] && [ -n "$data" ]; then
                    response=$(curl -s -w "%{http_code}" -X POST "$API_URL$endpoint" \
                        -H "Content-Type: application/json" \
                        -d "$data" -o response.json)
                else
                    response=$(curl -s -w "%{http_code}" -o response.json "$API_URL$endpoint")
                fi
                
                if [ "$response" = "$expected_status" ]; then
                    echo "‚úÖ $description - OK ($response)"
                    return 0
                else
                    echo "‚ùå $description - FAILED ($response)"
                    echo "Response body:"
                    cat response.json 2>/dev/null || echo "No response body"
                    return 1
                fi
            }
            
            # Run comprehensive API tests
            TESTS_PASSED=true
            
            # Basic health check
            test_endpoint "/health" "200" "Health endpoint" || TESTS_PASSED=false
            
            # People endpoints
            test_endpoint "/people" "200" "People list endpoint" || TESTS_PASSED=false
            
            # Test person creation
            echo "Testing person creation..."
            create_data='{
                "firstName": "Test",
                "lastName": "User",
                "email": "test-deploy@example.com",
                "phone": "+1-555-0199",
                "dateOfBirth": "1990-01-01",
                "address": {
                    "street": "123 Test St",
                    "city": "Test City",
                    "state": "TS",
                    "zipCode": "12345",
                    "country": "USA"
                }
            }'
            
            create_response=$(curl -s -w "%{http_code}" -X POST "$API_URL/people" \
                -H "Content-Type: application/json" \
                -d "$create_data" -o create_response.json)
            
            if [ "$create_response" = "201" ]; then
                echo "‚úÖ Person creation - OK"
                PERSON_ID=$(jq -r '.id' create_response.json 2>/dev/null || echo "")
                
                if [ -n "$PERSON_ID" ] && [ "$PERSON_ID" != "null" ]; then
                    # Test person retrieval
                    test_endpoint "/people/$PERSON_ID" "200" "Person retrieval" || TESTS_PASSED=false
                    
                    # Clean up test person
                    delete_response=$(curl -s -w "%{http_code}" -X DELETE "$API_URL/people/$PERSON_ID" -o /dev/null)
                    if [ "$delete_response" = "204" ]; then
                        echo "‚úÖ Test cleanup - OK"
                    else
                        echo "‚ö†Ô∏è Test cleanup failed ($delete_response)"
                    fi
                fi
            else
                echo "‚ùå Person creation - FAILED ($create_response)"
                cat create_response.json 2>/dev/null || echo "No response body"
                TESTS_PASSED=false
            fi
            
            # Test search endpoint (if available)
            test_endpoint "/people/search" "200" "People search endpoint" || echo "‚ö†Ô∏è Search endpoint not available (non-critical)"
            
            # Generate test report
            # Generate test report
            echo "Post-Deployment Test Report" > post-deployment-test-report.txt
            echo "==========================" >> post-deployment-test-report.txt
            echo "Timestamp: $(date)" >> post-deployment-test-report.txt
            echo "API URL: $API_URL" >> post-deployment-test-report.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> post-deployment-test-report.txt
            echo "Handler Used: $HANDLER_USED" >> post-deployment-test-report.txt
            if [ "$TESTS_PASSED" = true ]; then
                echo "Overall Status: PASSED" >> post-deployment-test-report.txt
            else
                echo "Overall Status: FAILED" >> post-deployment-test-report.txt
            fi
            echo "" >> post-deployment-test-report.txt
            echo "Test Results:" >> post-deployment-test-report.txt
            if test_endpoint "/health" "200" "Health endpoint" >/dev/null 2>&1; then
                echo "- Health endpoint: PASS" >> post-deployment-test-report.txt
            else
                echo "- Health endpoint: FAIL" >> post-deployment-test-report.txt
            fi
            if test_endpoint "/people" "200" "People list endpoint" >/dev/null 2>&1; then
                echo "- People list: PASS" >> post-deployment-test-report.txt
            else
                echo "- People list: FAIL" >> post-deployment-test-report.txt
            fi
            if [ "$create_response" = "201" ]; then
                echo "- Person CRUD: PASS" >> post-deployment-test-report.txt
            else
                echo "- Person CRUD: FAIL" >> post-deployment-test-report.txt
            fi
            echo "" >> post-deployment-test-report.txt
            if [ "$TESTS_PASSED" = true ]; then
                echo "‚úÖ All critical tests passed" >> post-deployment-test-report.txt
            else
                echo "‚ùå Some tests failed" >> post-deployment-test-report.txt
            fi
            
            cat post-deployment-test-report.txt
            
            if [ "$TESTS_PASSED" = true ]; then
                echo "üéâ Post-deployment tests passed!"
                exit 0
            else
                echo "‚ùå Some post-deployment tests failed"
                exit 1
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: testReport
          Files:
            - "post-deployment-test-report.txt"

  NotifyDeploymentStatus:
    Identifier: aws/build@v1
    DependsOn:
      - PostDeploymentTests
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentSummary
        - testReport
    Configuration:
      Steps:
        - Run: |
            echo "üì¢ Deployment Status Notification"
            echo "================================"
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "üìä Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            # Read deployment and test results
            if [ -f "deployment-summary.json" ]; then
                API_URL=$(jq -r '.outputs.api_url' deployment-summary.json)
                FRONTEND_URL=$(jq -r '.outputs.frontend_url' deployment-summary.json)
                S3_BUCKET=$(jq -r '.outputs.s3_bucket' deployment-summary.json)
                DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-summary.json)
                HANDLER_USED=$(jq -r '.handler_used' deployment-summary.json)
                EXECUTION_MODE_FROM_SUMMARY=$(jq -r '.execution_mode // "unknown"' deployment-summary.json)
                TRIGGER_TYPE_FROM_SUMMARY=$(jq -r '.trigger_type // "unknown"' deployment-summary.json)
            else
                echo "‚ö†Ô∏è Deployment summary not available"
                API_URL="unknown"
                FRONTEND_URL="unknown"
                S3_BUCKET="unknown"
                DEPLOYMENT_TYPE="unknown"
                HANDLER_USED="unknown"
                EXECUTION_MODE_FROM_SUMMARY="unknown"
                TRIGGER_TYPE_FROM_SUMMARY="unknown"
            fi
            
            # Create comprehensive deployment notification based on execution mode
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "üîç Infrastructure Validation Completed!" > deployment-notification.txt
                echo "=======================================" >> deployment-notification.txt
            else
                echo "üöÄ Infrastructure Deployment Completed Successfully!" > deployment-notification.txt
                echo "==================================================" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            echo "Execution Information:" >> deployment-notification.txt
            echo "=====================" >> deployment-notification.txt
            echo "Timestamp: $(date)" >> deployment-notification.txt
            echo "Execution Mode: $EXECUTION_MODE" >> deployment-notification.txt
            echo "Trigger Type: $TRIGGER_TYPE" >> deployment-notification.txt
            echo "Branch: $BRANCH_NAME" >> deployment-notification.txt
            echo "Commit: ${CODECATALYST_SOURCE_BRANCH_REF:-unknown}" >> deployment-notification.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> deployment-notification.txt
            echo "Handler Used: $HANDLER_USED" >> deployment-notification.txt
            echo "" >> deployment-notification.txt
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "Validation Results:" >> deployment-notification.txt
                echo "==================" >> deployment-notification.txt
                echo "‚úÖ API Code Synchronization: Validated" >> deployment-notification.txt
                echo "‚úÖ API Integration: Validated" >> deployment-notification.txt
                echo "‚úÖ Infrastructure Configuration: Validated" >> deployment-notification.txt
                echo "‚è≠Ô∏è Deployment: Skipped (validation mode)" >> deployment-notification.txt
                echo "‚è≠Ô∏è Testing: Skipped (validation mode)" >> deployment-notification.txt
            else
                echo "Deployed Resources:" >> deployment-notification.txt
                echo "==================" >> deployment-notification.txt
                echo "üåê API Gateway: $API_URL" >> deployment-notification.txt
                echo "üé® Frontend (CloudFront): $FRONTEND_URL" >> deployment-notification.txt
                echo "üì¶ S3 Bucket: $S3_BUCKET" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            echo "Integration Status:" >> deployment-notification.txt
            echo "==================" >> deployment-notification.txt
            if [ "$DEPLOYMENT_TYPE" = "api_sync" ]; then
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    echo "‚úÖ Registry-API code integration validated" >> deployment-notification.txt
                else
                    echo "‚úÖ Registry-API code successfully integrated" >> deployment-notification.txt
                fi
            else
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    echo "‚ÑπÔ∏è Infrastructure handlers validation completed" >> deployment-notification.txt
                else
                    echo "‚ÑπÔ∏è Using existing infrastructure handlers" >> deployment-notification.txt
                fi
            fi
            if [ -f "post-deployment-test-report.txt" ]; then
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    echo "‚è≠Ô∏è Post-deployment tests skipped (validation mode)" >> deployment-notification.txt
                else
                    echo "‚úÖ Post-deployment tests completed" >> deployment-notification.txt
                fi
            else
                echo "‚ö†Ô∏è Post-deployment tests not available" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            echo "Next Steps:" >> deployment-notification.txt
            echo "==========" >> deployment-notification.txt
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "1. Review validation results and fix any issues" >> deployment-notification.txt
                echo "2. Merge pull request after validation passes" >> deployment-notification.txt
                echo "3. Full deployment will run automatically on main branch" >> deployment-notification.txt
                echo "4. Monitor for any integration issues" >> deployment-notification.txt
            else
                echo "1. Verify API endpoints are working correctly" >> deployment-notification.txt
                echo "2. Update frontend configuration if needed" >> deployment-notification.txt
                echo "3. Monitor application performance and logs" >> deployment-notification.txt
                echo "4. Coordinate with registry-api team for any issues" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            if [ "$DEPLOYMENT_TYPE" = "api_sync" ]; then
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    echo "üîÑ This validation included synchronized code from registry-api repository" >> deployment-notification.txt
                else
                    echo "üîÑ This deployment included synchronized code from registry-api repository" >> deployment-notification.txt
                fi
                echo "" >> deployment-notification.txt
            fi
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "Validation completed successfully! ‚úÖ" >> deployment-notification.txt
            else
                echo "Deployment completed successfully! üéâ" >> deployment-notification.txt
            fi
            
            cat deployment-notification.txt
            
            # Store notification for potential external systems
            echo "üì§ Storing deployment notification..."
            
            # This could be extended to send notifications to Slack, email, etc.
            echo "‚úÖ Deployment notification completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentNotification
          Files:
            - "deployment-notification.txt"