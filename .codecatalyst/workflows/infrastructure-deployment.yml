Name: Infrastructure_Deployment_Pipeline
SchemaVersion: "1.0"

Triggers:
  - Type: PUSH
    Branches:
      - main
  - Type: MANUAL

Actions:
  CheckAPISync:
    Identifier: aws/build@v1
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
    Configuration:
      Commands:
        - Run: |
            echo "ðŸ” Checking API Code Synchronization"
            echo "==================================="
            
            # Check if this deployment was triggered by API sync
            if [ -f "lambda/main.py" ] && [ -d "lambda/src" ]; then
                echo "âœ… API code synchronized from registry-api repository"
                echo "ðŸ“Š API sync detected:"
                echo "  - main.py: $([ -f "lambda/main.py" ] && echo "Present" || echo "Missing")"
                echo "  - src/ directory: $([ -d "lambda/src" ] && echo "Present" || echo "Missing")"
                echo "  - requirements.txt: $([ -f "lambda/requirements.txt" ] && echo "Present" || echo "Missing")"
                
                # Check for sync metadata
                if [ -f "lambda/sync-metadata.json" ]; then
                    echo "ðŸ“‹ Sync metadata found:"
                    cat lambda/sync-metadata.json
                fi
                
                echo "ðŸ”„ Proceeding with infrastructure deployment using synchronized API code"
            else
                echo "â„¹ï¸ No API sync detected - using existing lambda handlers"
                echo "ðŸ“Š Current lambda structure:"
                ls -la lambda/ || echo "Lambda directory not found"
            fi
            
            # Create deployment context
            DEPLOYMENT_TYPE=$([ -f "lambda/main.py" ] && echo "api_sync" || echo "infrastructure_only")
            API_SYNC_DETECTED=$([ -f "lambda/main.py" ] && echo "true" || echo "false")
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            BRANCH=${CODECATALYST_SOURCE_BRANCH_NAME:-main}
            COMMIT=${CODECATALYST_SOURCE_BRANCH_REF:-unknown}
            
            echo "{" > deployment-context.json
            echo "  \"deployment_type\": \"$DEPLOYMENT_TYPE\"," >> deployment-context.json
            echo "  \"timestamp\": \"$TIMESTAMP\"," >> deployment-context.json
            echo "  \"branch\": \"$BRANCH\"," >> deployment-context.json
            echo "  \"commit\": \"$COMMIT\"," >> deployment-context.json
            echo "  \"api_sync_detected\": $API_SYNC_DETECTED" >> deployment-context.json
            echo "}" >> deployment-context.json
            
            cat deployment-context.json
            echo "âœ… API sync check completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentContext
          Files:
            - "deployment-context.json"

  PrepareAPIIntegration:
    Identifier: aws/build@v1
    DependsOn:
      - CheckAPISync
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
    Configuration:
      Commands:
        - Run: |
            echo "ðŸ”§ Preparing API Integration"
            echo "==========================="
            
            # Read deployment context
            DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-context.json)
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            
            echo "Deployment type: $DEPLOYMENT_TYPE"
            echo "API sync detected: $API_SYNC_DETECTED"
            
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "ðŸ”„ Integrating synchronized API code with infrastructure"
                
                # Create integrated Lambda handler that uses the new API structure
                echo "Creating integrated API handler..."
                mkdir -p lambda
                
                # Create a basic integrated handler file
                echo "# Integrated API Handler - Bridges registry-api code with Lambda infrastructure" > lambda/integrated_api_handler.py
                echo "import json" >> lambda/integrated_api_handler.py
                echo "import logging" >> lambda/integrated_api_handler.py
                echo "import os" >> lambda/integrated_api_handler.py
                echo "import sys" >> lambda/integrated_api_handler.py
                echo "from typing import Dict, Any" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "# Add the src directory to Python path for registry-api imports" >> lambda/integrated_api_handler.py
                echo "sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "# Configure logging" >> lambda/integrated_api_handler.py
                echo "logging.basicConfig(level=logging.INFO)" >> lambda/integrated_api_handler.py
                echo "logger = logging.getLogger(__name__)" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:" >> lambda/integrated_api_handler.py
                echo "    try:" >> lambda/integrated_api_handler.py
                echo "        logger.info(f'Received event: {json.dumps(event, default=str)}')" >> lambda/integrated_api_handler.py
                echo "        try:" >> lambda/integrated_api_handler.py
                echo "            from main import app" >> lambda/integrated_api_handler.py
                echo "            from mangum import Mangum" >> lambda/integrated_api_handler.py
                echo "            handler = Mangum(app, lifespan='off')" >> lambda/integrated_api_handler.py
                echo "            response = handler(event, context)" >> lambda/integrated_api_handler.py
                echo "            logger.info(f'Response status: {response.get(\"statusCode\", \"unknown\")}')" >> lambda/integrated_api_handler.py
                echo "            return response" >> lambda/integrated_api_handler.py
                echo "        except ImportError as e:" >> lambda/integrated_api_handler.py
                echo "            logger.error(f'Failed to import registry-api components: {str(e)}')" >> lambda/integrated_api_handler.py
                echo "            try:" >> lambda/integrated_api_handler.py
                echo "                from enhanced_api_handler import lambda_handler as fallback_handler" >> lambda/integrated_api_handler.py
                echo "                logger.info('Using fallback enhanced_api_handler')" >> lambda/integrated_api_handler.py
                echo "                return fallback_handler(event, context)" >> lambda/integrated_api_handler.py
                echo "            except ImportError:" >> lambda/integrated_api_handler.py
                echo "                return {'statusCode': 500, 'body': json.dumps({'error': 'API handler not available'})}" >> lambda/integrated_api_handler.py
                echo "    except Exception as e:" >> lambda/integrated_api_handler.py
                echo "        logger.error(f'Lambda handler error: {str(e)}', exc_info=True)" >> lambda/integrated_api_handler.py
                echo "        return {'statusCode': 500, 'body': json.dumps({'error': 'Internal Server Error'})}" >> lambda/integrated_api_handler.py
                
                # Update requirements.txt to include registry-api dependencies
                if [ -f "lambda/requirements.txt" ]; then
                    echo "ðŸ“¦ Merging requirements from registry-api"
                    
                    # Create merged requirements
                    # Create merged requirements file
                    echo "# Infrastructure requirements (existing)" > lambda/requirements_merged.txt
                    echo "boto3==1.34.144" >> lambda/requirements_merged.txt
                    echo "botocore==1.34.144" >> lambda/requirements_merged.txt
                    echo "pydantic==2.10.3" >> lambda/requirements_merged.txt
                    echo "bcrypt==4.1.3" >> lambda/requirements_merged.txt
                    echo "pyjwt==2.8.0" >> lambda/requirements_merged.txt
                    echo "python-json-logger==2.0.7" >> lambda/requirements_merged.txt
                    echo "" >> lambda/requirements_merged.txt
                    echo "# Registry-API requirements (synchronized)" >> lambda/requirements_merged.txt
                    echo "fastapi==0.111.0" >> lambda/requirements_merged.txt
                    echo "mangum==0.17.0" >> lambda/requirements_merged.txt
                    echo "python-multipart>=0.0.7" >> lambda/requirements_merged.txt
                    echo "pytest==8.2.2" >> lambda/requirements_merged.txt
                    echo "pytest-mock==3.14.0" >> lambda/requirements_merged.txt
                    echo "moto==5.0.9" >> lambda/requirements_merged.txt
                    
                    # Replace original requirements
                    mv lambda/requirements_merged.txt lambda/requirements.txt
                    
                    echo "âœ… Requirements merged successfully"
                else
                    echo "âš ï¸ No requirements.txt found in lambda directory"
                fi
                
                echo "âœ… API integration prepared successfully"
            else
                echo "â„¹ï¸ No API sync detected - using existing infrastructure handlers"
            fi
            
            # Create integration summary
            # Create integration summary
            echo "API Integration Summary" > api-integration-summary.txt
            echo "======================" >> api-integration-summary.txt
            echo "Timestamp: $(date)" >> api-integration-summary.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> api-integration-summary.txt
            echo "API Sync Detected: $API_SYNC_DETECTED" >> api-integration-summary.txt
            echo "" >> api-integration-summary.txt
            echo "Integration Actions:" >> api-integration-summary.txt
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "âœ… Created integrated_api_handler.py" >> api-integration-summary.txt
                echo "âœ… Merged requirements.txt" >> api-integration-summary.txt
            else
                echo "â„¹ï¸ No integration needed" >> api-integration-summary.txt
                echo "â„¹ï¸ Using existing requirements" >> api-integration-summary.txt
            fi
            echo "" >> api-integration-summary.txt
            echo "Handler Priority:" >> api-integration-summary.txt
            echo "1. integrated_api_handler.py (if API sync detected)" >> api-integration-summary.txt
            echo "2. enhanced_api_handler.py (fallback)" >> api-integration-summary.txt
            echo "3. api_handler.py (legacy fallback)" >> api-integration-summary.txt
            
            cat api-integration-summary.txt
            echo "âœ… API integration preparation completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: apiIntegration
          Files:
            - "api-integration-summary.txt"
            - "lambda/integrated_api_handler.py"

  ValidateInfrastructure:
    Identifier: aws/build@v1
    DependsOn:
      - PrepareAPIIntegration
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
        - apiIntegration
    Configuration:
      Commands:
        - Run: |
            echo "ðŸ” Infrastructure Validation"
            echo "=========================="
            
            # Install required tools
            echo "ðŸ“¦ Installing required tools..."
            curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin
            
            # Environment info
            echo "Environment Information:"
            echo "Node version: $(node --version)"
            echo "npm version: $(npm --version)"
            echo "Python version: $(python3 --version)"
            echo "Just version: $(just --version)"
            
            # Check AWS credentials
            echo "ðŸ” Checking AWS credentials..."
            if aws sts get-caller-identity; then
                echo "âœ… AWS credentials are valid"
            else
                echo "âŒ AWS credentials are invalid"
                exit 1
            fi
            
            # Fix Lambda runtime compatibility
            echo "ðŸ”§ Fixing Lambda runtime compatibility..."
            if [ -f "people_register_infrastructure/people_register_infrastructure_stack.py" ]; then
                cp people_register_infrastructure/people_register_infrastructure_stack.py people_register_infrastructure/people_register_infrastructure_stack.py.backup
                sed -i 's/runtime=_lambda\.Runtime\.PYTHON_3_11/runtime=_lambda.Runtime.PYTHON_3_9/g' people_register_infrastructure/people_register_infrastructure_stack.py
                echo "âœ… Updated Lambda runtime from PYTHON_3_11 to PYTHON_3_9"
            fi
            
            # Update CDK stack to use integrated handler if API sync detected
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "ðŸ”§ Updating CDK stack to use integrated API handler..."
                
                # Update the handler reference in the CDK stack
                if [ -f "people_register_infrastructure/people_register_infrastructure_stack.py" ]; then
                    sed -i 's/handler="enhanced_api_handler.lambda_handler"/handler="integrated_api_handler.lambda_handler"/g' people_register_infrastructure/people_register_infrastructure_stack.py
                    echo "âœ… Updated CDK stack to use integrated_api_handler"
                fi
            fi
            
            # Python environment setup
            echo "ðŸ”„ Setting up Python environment..."
            python3 -m venv .venv
            source .venv/bin/activate
            
            # Install compatible CDK dependencies
            echo "ðŸ”„ Installing compatible Python CDK dependencies..."
            pip install aws-cdk-lib==2.80.0 constructs>=10.0.0,\<11.0.0 boto3>=1.34.0 pydantic>=2.7.0
            
            # Install compatible CDK CLI
            echo "ðŸ”„ Installing compatible CDK CLI..."
            npm uninstall -g aws-cdk 2>/dev/null || echo "No existing CDK to uninstall"
            npm install -g aws-cdk@2.80.0
            
            # CDK version check
            echo "CDK version: $(cdk --version)"
            
            # CDK synthesis validation
            echo "ðŸ”„ Testing CDK synthesis..."
            if source .venv/bin/activate && cdk synth --quiet; then
                echo "âœ… CDK synthesis validation - SUCCESS"
            else
                echo "âŒ CDK synthesis validation failed"
                exit 1
            fi
            
            echo "âœ… Infrastructure validation completed successfully"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03

  DeployInfrastructure:
    Identifier: aws/build@v1
    DependsOn:
      - ValidateInfrastructure
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
        - apiIntegration
    Configuration:
      Commands:
        - Run: |
            echo "ðŸš€ Infrastructure Deployment"
            echo "=========================="
            
            # Only deploy on main branch
            if [ "${CODECATALYST_SOURCE_BRANCH_NAME}" != "main" ]; then
                echo "â„¹ï¸ Not on main branch - skipping deployment"
                exit 0
            fi
            
            # Setup environment
            python3 -m venv .venv
            source .venv/bin/activate
            pip install aws-cdk-lib==2.80.0 constructs>=10.0.0,\<11.0.0 boto3>=1.34.0 pydantic>=2.7.0
            npm install -g aws-cdk@2.80.0
            
            # Read deployment context
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-context.json)
            
            echo "ðŸ—ï¸ Starting CDK deployment..."
            echo "Deployment type: $DEPLOYMENT_TYPE"
            echo "API sync detected: $API_SYNC_DETECTED"
            
            # Deploy infrastructure
            if source .venv/bin/activate && cdk deploy --require-approval never --outputs-file outputs.json; then
                echo "âœ… CDK deployment - SUCCESS"
                
                # Extract deployment outputs
                echo "ðŸ” Extracting deployment outputs..."
                if [ -f "outputs.json" ]; then
                    API_URL=$(cat outputs.json | jq -r '.PeopleRegisterInfrastructureStack.ApiUrl // empty')
                    FRONTEND_URL=$(cat outputs.json | jq -r '.PeopleRegisterInfrastructureStack.FrontendUrl // empty')
                    S3_BUCKET=$(cat outputs.json | jq -r '.PeopleRegisterInfrastructureStack.S3BucketName // empty')
                    
                    echo "ðŸ“Š DEPLOYMENT INFORMATION:"
                    echo "API URL: $API_URL"
                    echo "Frontend URL: $FRONTEND_URL"
                    echo "S3 Bucket: $S3_BUCKET"
                    
                    # Create deployment summary
                    HANDLER_USED=$([ "$API_SYNC_DETECTED" = "true" ] && echo "integrated_api_handler" || echo "enhanced_api_handler")
                    TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
                    
                    echo "{" > deployment-summary.json
                    echo "  \"deployment_successful\": true," >> deployment-summary.json
                    echo "  \"deployment_type\": \"$DEPLOYMENT_TYPE\"," >> deployment-summary.json
                    echo "  \"api_sync_detected\": $API_SYNC_DETECTED," >> deployment-summary.json
                    echo "  \"timestamp\": \"$TIMESTAMP\"," >> deployment-summary.json
                    echo "  \"outputs\": {" >> deployment-summary.json
                    echo "    \"api_url\": \"$API_URL\"," >> deployment-summary.json
                    echo "    \"frontend_url\": \"$FRONTEND_URL\"," >> deployment-summary.json
                    echo "    \"s3_bucket\": \"$S3_BUCKET\"" >> deployment-summary.json
                    echo "  }," >> deployment-summary.json
                    echo "  \"handler_used\": \"$HANDLER_USED\"" >> deployment-summary.json
                    echo "}" >> deployment-summary.json
                    
                    cat deployment-summary.json
                    echo "âœ… Infrastructure deployment completed successfully"
                else
                    echo "âš ï¸ outputs.json not found"
                    exit 1
                fi
            else
                echo "âŒ CDK deployment failed"
                exit 1
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentSummary
          Files:
            - "deployment-summary.json"
            - "outputs.json"

  PostDeploymentTests:
    Identifier: aws/build@v1
    DependsOn:
      - DeployInfrastructure
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentSummary
    Configuration:
      Commands:
        - Run: |
            echo "ðŸ§ª Post-Deployment Testing"
            echo "========================="
            
            # Only run tests on main branch
            if [ "${CODECATALYST_SOURCE_BRANCH_NAME}" != "main" ]; then
                echo "â„¹ï¸ Not on main branch - skipping post-deployment tests"
                exit 0
            fi
            
            # Read deployment summary
            if [ -f "deployment-summary.json" ]; then
                API_URL=$(jq -r '.outputs.api_url' deployment-summary.json)
                DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-summary.json)
                HANDLER_USED=$(jq -r '.handler_used' deployment-summary.json)
                
                echo "Testing deployed infrastructure:"
                echo "API URL: $API_URL"
                echo "Deployment type: $DEPLOYMENT_TYPE"
                echo "Handler used: $HANDLER_USED"
            else
                echo "âŒ Deployment summary not found"
                exit 1
            fi
            
            # Wait for deployment to stabilize
            echo "â³ Waiting for deployment to stabilize..."
            sleep 30
            
            # Test function
            test_endpoint() {
                local endpoint="$1"
                local expected_status="$2"
                local description="$3"
                local method="${4:-GET}"
                local data="${5:-}"
                
                echo "Testing $description..."
                
                if [ "$method" = "POST" ] && [ -n "$data" ]; then
                    response=$(curl -s -w "%{http_code}" -X POST "$API_URL$endpoint" \
                        -H "Content-Type: application/json" \
                        -d "$data" -o response.json)
                else
                    response=$(curl -s -w "%{http_code}" -o response.json "$API_URL$endpoint")
                fi
                
                if [ "$response" = "$expected_status" ]; then
                    echo "âœ… $description - OK ($response)"
                    return 0
                else
                    echo "âŒ $description - FAILED ($response)"
                    echo "Response body:"
                    cat response.json 2>/dev/null || echo "No response body"
                    return 1
                fi
            }
            
            # Run comprehensive API tests
            TESTS_PASSED=true
            
            # Basic health check
            test_endpoint "/health" "200" "Health endpoint" || TESTS_PASSED=false
            
            # People endpoints
            test_endpoint "/people" "200" "People list endpoint" || TESTS_PASSED=false
            
            # Test person creation
            echo "Testing person creation..."
            create_data='{
                "firstName": "Test",
                "lastName": "User",
                "email": "test-deploy@example.com",
                "phone": "+1-555-0199",
                "dateOfBirth": "1990-01-01",
                "address": {
                    "street": "123 Test St",
                    "city": "Test City",
                    "state": "TS",
                    "zipCode": "12345",
                    "country": "USA"
                }
            }'
            
            create_response=$(curl -s -w "%{http_code}" -X POST "$API_URL/people" \
                -H "Content-Type: application/json" \
                -d "$create_data" -o create_response.json)
            
            if [ "$create_response" = "201" ]; then
                echo "âœ… Person creation - OK"
                PERSON_ID=$(jq -r '.id' create_response.json 2>/dev/null || echo "")
                
                if [ -n "$PERSON_ID" ] && [ "$PERSON_ID" != "null" ]; then
                    # Test person retrieval
                    test_endpoint "/people/$PERSON_ID" "200" "Person retrieval" || TESTS_PASSED=false
                    
                    # Clean up test person
                    delete_response=$(curl -s -w "%{http_code}" -X DELETE "$API_URL/people/$PERSON_ID" -o /dev/null)
                    if [ "$delete_response" = "204" ]; then
                        echo "âœ… Test cleanup - OK"
                    else
                        echo "âš ï¸ Test cleanup failed ($delete_response)"
                    fi
                fi
            else
                echo "âŒ Person creation - FAILED ($create_response)"
                cat create_response.json 2>/dev/null || echo "No response body"
                TESTS_PASSED=false
            fi
            
            # Test search endpoint (if available)
            test_endpoint "/people/search" "200" "People search endpoint" || echo "âš ï¸ Search endpoint not available (non-critical)"
            
            # Generate test report
            # Generate test report
            echo "Post-Deployment Test Report" > post-deployment-test-report.txt
            echo "==========================" >> post-deployment-test-report.txt
            echo "Timestamp: $(date)" >> post-deployment-test-report.txt
            echo "API URL: $API_URL" >> post-deployment-test-report.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> post-deployment-test-report.txt
            echo "Handler Used: $HANDLER_USED" >> post-deployment-test-report.txt
            if [ "$TESTS_PASSED" = true ]; then
                echo "Overall Status: PASSED" >> post-deployment-test-report.txt
            else
                echo "Overall Status: FAILED" >> post-deployment-test-report.txt
            fi
            echo "" >> post-deployment-test-report.txt
            echo "Test Results:" >> post-deployment-test-report.txt
            if test_endpoint "/health" "200" "Health endpoint" >/dev/null 2>&1; then
                echo "- Health endpoint: PASS" >> post-deployment-test-report.txt
            else
                echo "- Health endpoint: FAIL" >> post-deployment-test-report.txt
            fi
            if test_endpoint "/people" "200" "People list endpoint" >/dev/null 2>&1; then
                echo "- People list: PASS" >> post-deployment-test-report.txt
            else
                echo "- People list: FAIL" >> post-deployment-test-report.txt
            fi
            if [ "$create_response" = "201" ]; then
                echo "- Person CRUD: PASS" >> post-deployment-test-report.txt
            else
                echo "- Person CRUD: FAIL" >> post-deployment-test-report.txt
            fi
            echo "" >> post-deployment-test-report.txt
            if [ "$TESTS_PASSED" = true ]; then
                echo "âœ… All critical tests passed" >> post-deployment-test-report.txt
            else
                echo "âŒ Some tests failed" >> post-deployment-test-report.txt
            fi
            
            cat post-deployment-test-report.txt
            
            if [ "$TESTS_PASSED" = true ]; then
                echo "ðŸŽ‰ Post-deployment tests passed!"
                exit 0
            else
                echo "âŒ Some post-deployment tests failed"
                exit 1
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: testReport
          Files:
            - "post-deployment-test-report.txt"

  NotifyDeploymentStatus:
    Identifier: aws/build@v1
    DependsOn:
      - PostDeploymentTests
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentSummary
        - testReport
    Configuration:
      Commands:
        - Run: |
            echo "ðŸ“¢ Deployment Status Notification"
            echo "================================"
            
            # Read deployment and test results
            if [ -f "deployment-summary.json" ]; then
                API_URL=$(jq -r '.outputs.api_url' deployment-summary.json)
                FRONTEND_URL=$(jq -r '.outputs.frontend_url' deployment-summary.json)
                S3_BUCKET=$(jq -r '.outputs.s3_bucket' deployment-summary.json)
                DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-summary.json)
                HANDLER_USED=$(jq -r '.handler_used' deployment-summary.json)
            else
                echo "âš ï¸ Deployment summary not available"
                API_URL="unknown"
                FRONTEND_URL="unknown"
                S3_BUCKET="unknown"
                DEPLOYMENT_TYPE="unknown"
                HANDLER_USED="unknown"
            fi
            
            # Create comprehensive deployment notification
            # Create comprehensive deployment notification
            echo "ðŸš€ Infrastructure Deployment Completed Successfully!" > deployment-notification.txt
            echo "==================================================" >> deployment-notification.txt
            echo "" >> deployment-notification.txt
            echo "Deployment Information:" >> deployment-notification.txt
            echo "======================" >> deployment-notification.txt
            echo "Timestamp: $(date)" >> deployment-notification.txt
            echo "Branch: ${CODECATALYST_SOURCE_BRANCH_NAME:-main}" >> deployment-notification.txt
            echo "Commit: ${CODECATALYST_SOURCE_BRANCH_REF:-unknown}" >> deployment-notification.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> deployment-notification.txt
            echo "Handler Used: $HANDLER_USED" >> deployment-notification.txt
            echo "" >> deployment-notification.txt
            echo "Deployed Resources:" >> deployment-notification.txt
            echo "==================" >> deployment-notification.txt
            echo "ðŸŒ API Gateway: $API_URL" >> deployment-notification.txt
            echo "ðŸŽ¨ Frontend (CloudFront): $FRONTEND_URL" >> deployment-notification.txt
            echo "ðŸ“¦ S3 Bucket: $S3_BUCKET" >> deployment-notification.txt
            echo "" >> deployment-notification.txt
            echo "Integration Status:" >> deployment-notification.txt
            echo "==================" >> deployment-notification.txt
            if [ "$DEPLOYMENT_TYPE" = "api_sync" ]; then
                echo "âœ… Registry-API code successfully integrated" >> deployment-notification.txt
            else
                echo "â„¹ï¸ Using existing infrastructure handlers" >> deployment-notification.txt
            fi
            if [ -f "post-deployment-test-report.txt" ]; then
                echo "âœ… Post-deployment tests completed" >> deployment-notification.txt
            else
                echo "âš ï¸ Post-deployment tests not available" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            echo "Next Steps:" >> deployment-notification.txt
            echo "==========" >> deployment-notification.txt
            echo "1. Verify API endpoints are working correctly" >> deployment-notification.txt
            echo "2. Update frontend configuration if needed" >> deployment-notification.txt
            echo "3. Monitor application performance and logs" >> deployment-notification.txt
            echo "4. Coordinate with registry-api team for any issues" >> deployment-notification.txt
            echo "" >> deployment-notification.txt
            if [ "$DEPLOYMENT_TYPE" = "api_sync" ]; then
                echo "ðŸ”„ This deployment included synchronized code from registry-api repository" >> deployment-notification.txt
                echo "" >> deployment-notification.txt
            fi
            echo "Deployment completed successfully! ðŸŽ‰" >> deployment-notification.txt
            
            cat deployment-notification.txt
            
            # Store notification for potential external systems
            echo "ðŸ“¤ Storing deployment notification..."
            
            # This could be extended to send notifications to Slack, email, etc.
            echo "âœ… Deployment notification completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentNotification
          Files:
            - "deployment-notification.txt"