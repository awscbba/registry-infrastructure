Name: Infrastructure_Deployment_Pipeline
SchemaVersion: "1.0"

Triggers:
  - Type: PUSH
    Branches:
      - main
  - Type: PULLREQUEST
    Branches:
      - main
    Events:
      - PULLREQUEST_CREATED
      - PULLREQUEST_REVISION_CREATED
  - Type: MANUAL

Actions:
  CheckAPISync:
    Identifier: aws/build@v1
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
    Configuration:
      Steps:
        - Run: |
            echo "ðŸ” Checking API Code Synchronization"
            echo "==================================="
            
            # Execute execution mode detection
            echo "ðŸŽ¯ Detecting execution mode..."
            chmod +x scripts/execution-mode-detection.sh
            ./scripts/execution-mode-detection.sh
            
            # Source the execution mode environment variables
            source execution-mode-env.sh
            
            echo ""
            echo "ðŸ“Š Execution Mode: $EXECUTION_MODE"
            echo "ðŸ”„ Trigger Type: $TRIGGER_TYPE"
            echo "ðŸŒ¿ Branch: $BRANCH_NAME"
            echo ""
            
            # Check if this deployment was triggered by API sync
            if [ -f "lambda/main.py" ] && [ -d "lambda/src" ]; then
                echo "âœ… API code synchronized from registry-api repository"
                echo "ðŸ“Š API sync detected:"
                echo "  - main.py: $([ -f "lambda/main.py" ] && echo "Present" || echo "Missing")"
                echo "  - src/ directory: $([ -d "lambda/src" ] && echo "Present" || echo "Missing")"
                echo "  - requirements.txt: $([ -f "lambda/requirements.txt" ] && echo "Present" || echo "Missing")"
                
                # Check for sync metadata
                if [ -f "lambda/sync-metadata.json" ]; then
                    echo "ðŸ“‹ Sync metadata found:"
                    cat lambda/sync-metadata.json
                fi
                
                echo "ðŸ”„ Proceeding with infrastructure deployment using synchronized API code"
            else
                echo "â„¹ï¸ No API sync detected - using existing lambda handlers"
                echo "ðŸ“Š Current lambda structure:"
                ls -la lambda/ || echo "Lambda directory not found"
            fi
            
            # Create deployment context
            DEPLOYMENT_TYPE=$([ -f "lambda/main.py" ] && echo "api_sync" || echo "infrastructure_only")
            API_SYNC_DETECTED=$([ -f "lambda/main.py" ] && echo "true" || echo "false")
            TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            BRANCH=${CODECATALYST_SOURCE_BRANCH_NAME:-main}
            COMMIT=${CODECATALYST_SOURCE_BRANCH_REF:-unknown}
            
            # Merge execution context with deployment context
            echo "{" > deployment-context.json
            echo "  \"deployment_type\": \"$DEPLOYMENT_TYPE\"," >> deployment-context.json
            echo "  \"timestamp\": \"$TIMESTAMP\"," >> deployment-context.json
            echo "  \"branch\": \"$BRANCH\"," >> deployment-context.json
            echo "  \"commit\": \"$COMMIT\"," >> deployment-context.json
            echo "  \"api_sync_detected\": $API_SYNC_DETECTED," >> deployment-context.json
            echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> deployment-context.json
            echo "  \"trigger_type\": \"$TRIGGER_TYPE\"," >> deployment-context.json
            echo "  \"is_main_branch\": $IS_MAIN_BRANCH," >> deployment-context.json
            echo "  \"skip_deployment\": $SKIP_DEPLOYMENT," >> deployment-context.json
            echo "  \"skip_testing\": $SKIP_TESTING" >> deployment-context.json
            echo "}" >> deployment-context.json
            
            cat deployment-context.json
            echo "âœ… API sync check completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentContext
          Files:
            - "deployment-context.json"
            - "execution-context.json"
            - "execution-mode-env.sh"

  PrepareAPIIntegration:
    Identifier: aws/build@v1
    DependsOn:
      - CheckAPISync
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
    Configuration:
      Steps:
        - Run: |
            echo "ðŸ”§ Preparing API Integration"
            echo "==========================="
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            # Read deployment context
            DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-context.json)
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            
            echo "ðŸ“Š Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            echo "Deployment type: $DEPLOYMENT_TYPE"
            echo "API sync detected: $API_SYNC_DETECTED"
            
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "ðŸ”„ Integrating synchronized API code with infrastructure"
                
                # Create integrated Lambda handler that uses the new API structure
                echo "Creating integrated API handler..."
                mkdir -p lambda
                
                # Create a basic integrated handler file
                echo "# Integrated API Handler - Bridges registry-api code with Lambda infrastructure" > lambda/integrated_api_handler.py
                echo "import json" >> lambda/integrated_api_handler.py
                echo "import logging" >> lambda/integrated_api_handler.py
                echo "import os" >> lambda/integrated_api_handler.py
                echo "import sys" >> lambda/integrated_api_handler.py
                echo "from typing import Dict, Any" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "# Add the src directory to Python path for registry-api imports" >> lambda/integrated_api_handler.py
                echo "sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "# Configure logging" >> lambda/integrated_api_handler.py
                echo "logging.basicConfig(level=logging.INFO)" >> lambda/integrated_api_handler.py
                echo "logger = logging.getLogger(__name__)" >> lambda/integrated_api_handler.py
                echo "" >> lambda/integrated_api_handler.py
                echo "def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:" >> lambda/integrated_api_handler.py
                echo "    try:" >> lambda/integrated_api_handler.py
                echo "        logger.info(f'Received event: {json.dumps(event, default=str)}')" >> lambda/integrated_api_handler.py
                echo "        try:" >> lambda/integrated_api_handler.py
                echo "            from main import app" >> lambda/integrated_api_handler.py
                echo "            from mangum import Mangum" >> lambda/integrated_api_handler.py
                echo "            handler = Mangum(app, lifespan='off')" >> lambda/integrated_api_handler.py
                echo "            response = handler(event, context)" >> lambda/integrated_api_handler.py
                echo "            logger.info(f'Response status: {response.get(\"statusCode\", \"unknown\")}')" >> lambda/integrated_api_handler.py
                echo "            return response" >> lambda/integrated_api_handler.py
                echo "        except ImportError as e:" >> lambda/integrated_api_handler.py
                echo "            logger.error(f'Failed to import registry-api components: {str(e)}')" >> lambda/integrated_api_handler.py
                echo "            try:" >> lambda/integrated_api_handler.py
                echo "                from enhanced_api_handler import lambda_handler as fallback_handler" >> lambda/integrated_api_handler.py
                echo "                logger.info('Using fallback enhanced_api_handler')" >> lambda/integrated_api_handler.py
                echo "                return fallback_handler(event, context)" >> lambda/integrated_api_handler.py
                echo "            except ImportError:" >> lambda/integrated_api_handler.py
                echo "                return {'statusCode': 500, 'body': json.dumps({'error': 'API handler not available'})}" >> lambda/integrated_api_handler.py
                echo "    except Exception as e:" >> lambda/integrated_api_handler.py
                echo "        logger.error(f'Lambda handler error: {str(e)}', exc_info=True)" >> lambda/integrated_api_handler.py
                echo "        return {'statusCode': 500, 'body': json.dumps({'error': 'Internal Server Error'})}" >> lambda/integrated_api_handler.py
                
                # Update requirements.txt to include registry-api dependencies
                if [ -f "lambda/requirements.txt" ]; then
                    echo "ðŸ“¦ Merging requirements from registry-api"
                    
                    # Create merged requirements
                    # Create merged requirements file
                    echo "# Infrastructure requirements (existing)" > lambda/requirements_merged.txt
                    echo "boto3==1.34.144" >> lambda/requirements_merged.txt
                    echo "botocore==1.34.144" >> lambda/requirements_merged.txt
                    echo "pydantic==2.10.3" >> lambda/requirements_merged.txt
                    echo "bcrypt==4.1.3" >> lambda/requirements_merged.txt
                    echo "pyjwt==2.8.0" >> lambda/requirements_merged.txt
                    echo "python-json-logger==2.0.7" >> lambda/requirements_merged.txt
                    echo "" >> lambda/requirements_merged.txt
                    echo "# Registry-API requirements (synchronized)" >> lambda/requirements_merged.txt
                    echo "fastapi==0.111.0" >> lambda/requirements_merged.txt
                    echo "mangum==0.17.0" >> lambda/requirements_merged.txt
                    echo "python-multipart>=0.0.7" >> lambda/requirements_merged.txt
                    echo "pytest==8.2.2" >> lambda/requirements_merged.txt
                    echo "pytest-mock==3.14.0" >> lambda/requirements_merged.txt
                    echo "moto==5.0.9" >> lambda/requirements_merged.txt
                    
                    # Replace original requirements
                    mv lambda/requirements_merged.txt lambda/requirements.txt
                    
                    echo "âœ… Requirements merged successfully"
                else
                    echo "âš ï¸ No requirements.txt found in lambda directory"
                fi
                
                echo "âœ… API integration prepared successfully"
            else
                echo "â„¹ï¸ No API sync detected - using existing infrastructure handlers"
            fi
            
            # Create integration summary
            # Create integration summary
            echo "API Integration Summary" > api-integration-summary.txt
            echo "======================" >> api-integration-summary.txt
            echo "Timestamp: $(date)" >> api-integration-summary.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> api-integration-summary.txt
            echo "API Sync Detected: $API_SYNC_DETECTED" >> api-integration-summary.txt
            echo "" >> api-integration-summary.txt
            echo "Integration Actions:" >> api-integration-summary.txt
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "âœ… Created integrated_api_handler.py" >> api-integration-summary.txt
                echo "âœ… Merged requirements.txt" >> api-integration-summary.txt
            else
                echo "â„¹ï¸ No integration needed" >> api-integration-summary.txt
                echo "â„¹ï¸ Using existing requirements" >> api-integration-summary.txt
            fi
            echo "" >> api-integration-summary.txt
            echo "Handler Priority:" >> api-integration-summary.txt
            echo "1. integrated_api_handler.py (if API sync detected)" >> api-integration-summary.txt
            echo "2. enhanced_api_handler.py (fallback)" >> api-integration-summary.txt
            echo "3. api_handler.py (legacy fallback)" >> api-integration-summary.txt
            
            cat api-integration-summary.txt
            echo "âœ… API integration preparation completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: apiIntegration
          Files:
            - "api-integration-summary.txt"
            - "lambda/integrated_api_handler.py"

  ValidateInfrastructure:
    Identifier: aws/build@v1
    DependsOn:
      - PrepareAPIIntegration
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
        - apiIntegration
    Configuration:
      Steps:
        - Run: |
            echo "ðŸ” Enhanced Infrastructure Validation"
            echo "===================================="
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "ðŸ“Š Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            # Initialize validation results
            VALIDATION_ERRORS=0
            VALIDATION_WARNINGS=0
            VALIDATION_REPORT="validation-report.txt"
            
            echo "Infrastructure Validation Report" > $VALIDATION_REPORT
            echo "===============================" >> $VALIDATION_REPORT
            echo "Timestamp: $(date)" >> $VALIDATION_REPORT
            echo "Execution Mode: $EXECUTION_MODE" >> $VALIDATION_REPORT
            echo "Trigger Type: $TRIGGER_TYPE" >> $VALIDATION_REPORT
            echo "Branch: $BRANCH_NAME" >> $VALIDATION_REPORT
            echo "" >> $VALIDATION_REPORT
            
            # Install required tools
            echo "ðŸ“¦ Installing required tools..."
            curl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash -s -- --to /usr/local/bin
            
            # Environment info
            echo "Environment Information:"
            echo "Node version: $(node --version)"
            echo "npm version: $(npm --version)"
            echo "Python version: $(python3 --version)"
            echo "Just version: $(just --version)"
            
            # Function to log validation results
            log_validation() {
                local level="$1"
                local message="$2"
                local suggestion="${3:-}"
                
                echo "[$level] $message" | tee -a $VALIDATION_REPORT
                if [ -n "$suggestion" ]; then
                    echo "  ðŸ’¡ Suggestion: $suggestion" | tee -a $VALIDATION_REPORT
                fi
                
                if [ "$level" = "ERROR" ]; then
                    VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
                elif [ "$level" = "WARNING" ]; then
                    VALIDATION_WARNINGS=$((VALIDATION_WARNINGS + 1))
                fi
            }
            
            # 1. AWS Credentials Validation
            echo ""
            echo "ðŸ” Step 1: AWS Credentials Validation"
            echo "====================================="
            
            if aws sts get-caller-identity > aws-identity.json 2>&1; then
                ACCOUNT_ID=$(jq -r '.Account' aws-identity.json)
                USER_ARN=$(jq -r '.Arn' aws-identity.json)
                echo "âœ… AWS credentials are valid"
                echo "  Account ID: $ACCOUNT_ID"
                echo "  User/Role: $USER_ARN"
                log_validation "INFO" "AWS credentials validated successfully"
                log_validation "INFO" "Account ID: $ACCOUNT_ID"
                log_validation "INFO" "User/Role: $USER_ARN"
            else
                echo "âŒ AWS credentials are invalid"
                log_validation "ERROR" "AWS credentials validation failed" "Check your AWS credentials and permissions"
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            fi
            
            # 2. IAM Permission Validation
            echo ""
            echo "ðŸ”‘ Step 2: IAM Permission Validation"
            echo "===================================="
            
            echo "Testing required IAM permissions..."
            
            # Test DynamoDB permissions
            if aws dynamodb describe-limits --region us-east-1 >/dev/null 2>&1; then
                echo "  âœ… DynamoDB permissions: OK"
                log_validation "INFO" "DynamoDB permissions validated"
            else
                echo "  âŒ DynamoDB permissions: FAILED"
                log_validation "ERROR" "DynamoDB permissions insufficient" "Ensure your role has DynamoDB read/write permissions"
            fi
            
            # Test Lambda permissions
            if aws lambda list-functions --max-items 1 >/dev/null 2>&1; then
                echo "  âœ… Lambda permissions: OK"
                log_validation "INFO" "Lambda permissions validated"
            else
                echo "  âŒ Lambda permissions: FAILED"
                log_validation "ERROR" "Lambda permissions insufficient" "Ensure your role has Lambda create/update permissions"
            fi
            
            # Test S3 permissions
            if aws s3api list-buckets >/dev/null 2>&1; then
                echo "  âœ… S3 permissions: OK"
                log_validation "INFO" "S3 permissions validated"
            else
                echo "  âŒ S3 permissions: FAILED"
                log_validation "ERROR" "S3 permissions insufficient" "Ensure your role has S3 bucket management permissions"
            fi
            
            # Test IAM permissions
            if aws iam get-user >/dev/null 2>&1 || aws iam get-role --role-name CodeCatalystWorkflowDevelopmentRole-AWSCocha >/dev/null 2>&1; then
                echo "  âœ… IAM permissions: OK"
                log_validation "INFO" "IAM permissions validated"
            else
                echo "  âš ï¸ IAM permissions: LIMITED"
                log_validation "WARNING" "IAM permissions may be limited" "This might affect role creation during deployment"
            fi
            
            # 3. Resource Configuration Validation
            echo ""
            echo "ðŸ—ï¸ Step 3: Resource Configuration Validation"
            echo "==========================================="
            
            # Validate CDK stack configuration
            if [ -f "people_register_infrastructure/people_register_infrastructure_stack.py" ]; then
                echo "Validating CDK stack configuration..."
                
                # Check for common configuration issues
                if grep -q "PYTHON_3_11" people_register_infrastructure/people_register_infrastructure_stack.py; then
                    echo "  âš ï¸ Found PYTHON_3_11 runtime - will be updated to PYTHON_3_9"
                    log_validation "WARNING" "Lambda runtime PYTHON_3_11 detected" "Will be automatically updated to PYTHON_3_9 for compatibility"
                fi
                
                # Check for hardcoded values that should be parameterized
                if grep -q "your-jwt-secret-change-in-production" people_register_infrastructure/people_register_infrastructure_stack.py; then
                    echo "  âš ï¸ Default JWT secret detected"
                    log_validation "WARNING" "Default JWT secret found in configuration" "Consider using AWS Secrets Manager for production deployments"
                fi
                
                if grep -q "production-csrf-secret-change-this-value" people_register_infrastructure/people_register_infrastructure_stack.py; then
                    echo "  âš ï¸ Default CSRF secret detected"
                    log_validation "WARNING" "Default CSRF secret found in configuration" "Consider using AWS Secrets Manager for production deployments"
                fi
                
                # Check for proper removal policies
                if grep -q "RemovalPolicy.DESTROY" people_register_infrastructure/people_register_infrastructure_stack.py; then
                    echo "  â„¹ï¸ DESTROY removal policy detected (appropriate for development)"
                    log_validation "INFO" "DESTROY removal policy configured for development environment"
                fi
                
                echo "  âœ… CDK stack configuration validated"
                log_validation "INFO" "CDK stack configuration file validated"
            else
                echo "  âŒ CDK stack file not found"
                log_validation "ERROR" "CDK stack configuration file missing" "Ensure people_register_infrastructure_stack.py exists"
            fi
            
            # Validate Lambda handler files
            echo "Validating Lambda handler configuration..."
            LAMBDA_HANDLERS=("enhanced_api_handler.py" "auth_handler.py")
            
            for handler in "${LAMBDA_HANDLERS[@]}"; do
                if [ -f "lambda/$handler" ]; then
                    echo "  âœ… Found $handler"
                    log_validation "INFO" "Lambda handler $handler found"
                    
                    # Basic syntax check
                    if python3 -m py_compile "lambda/$handler" 2>/dev/null; then
                        echo "    âœ… Syntax validation passed"
                        log_validation "INFO" "Lambda handler $handler syntax validated"
                    else
                        echo "    âŒ Syntax validation failed"
                        log_validation "ERROR" "Lambda handler $handler has syntax errors" "Review Python syntax in $handler"
                    fi
                else
                    echo "  âŒ $handler not found"
                    log_validation "ERROR" "Required Lambda handler $handler missing" "Ensure $handler exists in lambda/ directory"
                fi
            done
            
            # Check for integrated handler (created during API integration)
            if [ -f "lambda/integrated_api_handler.py" ]; then
                echo "  âœ… Found integrated_api_handler.py"
                log_validation "INFO" "Integrated API handler found"
            else
                echo "  â„¹ï¸ integrated_api_handler.py not found (will be created if API sync detected)"
                log_validation "INFO" "Integrated API handler will be created during API integration if needed"
            fi
            
            # Validate requirements.txt
            if [ -f "lambda/requirements.txt" ]; then
                echo "  âœ… Lambda requirements.txt found"
                log_validation "INFO" "Lambda requirements.txt validated"
                
                # Check for potential dependency conflicts
                if grep -q "boto3" lambda/requirements.txt && grep -q "botocore" lambda/requirements.txt; then
                    echo "    â„¹ï¸ boto3 and botocore versions should be compatible"
                    log_validation "INFO" "boto3 and botocore dependencies found - ensure version compatibility"
                fi
            else
                echo "  âŒ Lambda requirements.txt not found"
                log_validation "ERROR" "Lambda requirements.txt missing" "Create requirements.txt with necessary Python dependencies"
            fi
            
            # 4. CDK Synthesis Validation (Enhanced)
            echo ""
            echo "âš™ï¸ Step 4: CDK Synthesis Validation"
            echo "=================================="
            
            # Fix Lambda runtime compatibility
            echo "ðŸ”§ Applying runtime compatibility fixes..."
            if [ -f "people_register_infrastructure/people_register_infrastructure_stack.py" ]; then
                cp people_register_infrastructure/people_register_infrastructure_stack.py people_register_infrastructure/people_register_infrastructure_stack.py.backup
                sed -i 's/runtime=_lambda\.Runtime\.PYTHON_3_11/runtime=_lambda.Runtime.PYTHON_3_9/g' people_register_infrastructure/people_register_infrastructure_stack.py
                echo "âœ… Updated Lambda runtime from PYTHON_3_11 to PYTHON_3_9"
                log_validation "INFO" "Lambda runtime updated to PYTHON_3_9 for compatibility"
            fi
            
            # Update CDK stack to use integrated handler if API sync detected
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            if [ "$API_SYNC_DETECTED" = "true" ]; then
                echo "ðŸ”§ Updating CDK stack to use integrated API handler..."
                
                # Update the handler reference in the CDK stack
                if [ -f "people_register_infrastructure/people_register_infrastructure_stack.py" ]; then
                    sed -i 's/handler="enhanced_api_handler.lambda_handler"/handler="integrated_api_handler.lambda_handler"/g' people_register_infrastructure/people_register_infrastructure_stack.py
                    echo "âœ… Updated CDK stack to use integrated_api_handler"
                    log_validation "INFO" "CDK stack updated to use integrated API handler"
                fi
            fi
            
            # Python environment setup
            echo "ðŸ”„ Setting up Python environment..."
            python3 -m venv .venv
            source .venv/bin/activate
            
            # Install compatible CDK dependencies
            echo "ðŸ”„ Installing compatible Python CDK dependencies..."
            if pip install aws-cdk-lib==2.80.0 constructs>=10.0.0,\<11.0.0 boto3>=1.34.0 pydantic>=2.7.0; then
                echo "âœ… CDK Python dependencies installed"
                log_validation "INFO" "CDK Python dependencies installed successfully"
            else
                echo "âŒ Failed to install CDK Python dependencies"
                log_validation "ERROR" "CDK Python dependencies installation failed" "Check pip and Python environment setup"
            fi
            
            # Install compatible CDK CLI
            echo "ðŸ”„ Installing compatible CDK CLI..."
            npm uninstall -g aws-cdk 2>/dev/null || echo "No existing CDK to uninstall"
            if npm install -g aws-cdk@2.80.0; then
                echo "âœ… CDK CLI installed"
                log_validation "INFO" "CDK CLI v2.80.0 installed successfully"
            else
                echo "âŒ Failed to install CDK CLI"
                log_validation "ERROR" "CDK CLI installation failed" "Check npm and Node.js setup"
            fi
            
            # CDK version check
            CDK_VERSION=$(cdk --version 2>/dev/null || echo "unknown")
            echo "CDK version: $CDK_VERSION"
            log_validation "INFO" "CDK version: $CDK_VERSION"
            
            # CDK synthesis validation with detailed error reporting
            echo "ðŸ”„ Performing CDK synthesis validation..."
            if source .venv/bin/activate && cdk synth --quiet > cdk-synth-output.json 2>cdk-synth-errors.txt; then
                echo "âœ… CDK synthesis validation - SUCCESS"
                log_validation "INFO" "CDK synthesis completed successfully"
                
                # Analyze synthesized template for potential issues
                if [ -f "cdk.out/PeopleRegisterInfrastructureStack.template.json" ]; then
                    TEMPLATE_SIZE=$(wc -c < "cdk.out/PeopleRegisterInfrastructureStack.template.json")
                    echo "  ðŸ“Š CloudFormation template size: $TEMPLATE_SIZE bytes"
                    log_validation "INFO" "CloudFormation template generated ($TEMPLATE_SIZE bytes)"
                    
                    # Check for template size limits (CloudFormation has a 51,200 byte limit for direct uploads)
                    if [ $TEMPLATE_SIZE -gt 51200 ]; then
                        echo "  âš ï¸ Template size exceeds direct upload limit"
                        log_validation "WARNING" "CloudFormation template size ($TEMPLATE_SIZE bytes) exceeds 51KB limit" "Template will be uploaded to S3 during deployment"
                    fi
                    
                    # Count resources
                    RESOURCE_COUNT=$(jq '.Resources | length' "cdk.out/PeopleRegisterInfrastructureStack.template.json" 2>/dev/null || echo "unknown")
                    echo "  ðŸ“Š CloudFormation resources: $RESOURCE_COUNT"
                    log_validation "INFO" "CloudFormation template contains $RESOURCE_COUNT resources"
                    
                    # Check for resource limits (CloudFormation has a 500 resource limit)
                    if [ "$RESOURCE_COUNT" != "unknown" ] && [ $RESOURCE_COUNT -gt 400 ]; then
                        echo "  âš ï¸ High resource count detected"
                        log_validation "WARNING" "High resource count ($RESOURCE_COUNT) approaching CloudFormation limit" "Consider splitting into multiple stacks if approaching 500 resources"
                    fi
                fi
            else
                echo "âŒ CDK synthesis validation - FAILED"
                log_validation "ERROR" "CDK synthesis failed" "Review CDK stack configuration and dependencies"
                
                # Provide detailed error analysis
                if [ -f "cdk-synth-errors.txt" ]; then
                    echo "ðŸ” CDK Synthesis Error Details:"
                    echo "==============================="
                    cat cdk-synth-errors.txt
                    
                    # Analyze common error patterns and provide suggestions
                    if grep -q "ModuleNotFoundError" cdk-synth-errors.txt; then
                        log_validation "ERROR" "Python module import error detected" "Check that all required Python packages are installed in the virtual environment"
                    fi
                    
                    if grep -q "ValidationError" cdk-synth-errors.txt; then
                        log_validation "ERROR" "CDK validation error detected" "Review CDK construct configuration and property values"
                    fi
                    
                    if grep -q "Cannot find module" cdk-synth-errors.txt; then
                        log_validation "ERROR" "Node.js module error detected" "Check that CDK CLI and dependencies are properly installed"
                    fi
                    
                    if grep -q "Credentials" cdk-synth-errors.txt; then
                        log_validation "ERROR" "AWS credentials error during synthesis" "Verify AWS credentials and permissions"
                    fi
                fi
                
                VALIDATION_ERRORS=$((VALIDATION_ERRORS + 1))
            fi
            
            # 5. Generate Validation Summary
            echo ""
            echo "ðŸ“‹ Step 5: Validation Summary"
            echo "============================"
            
            echo "" >> $VALIDATION_REPORT
            echo "VALIDATION SUMMARY" >> $VALIDATION_REPORT
            echo "==================" >> $VALIDATION_REPORT
            echo "Total Errors: $VALIDATION_ERRORS" >> $VALIDATION_REPORT
            echo "Total Warnings: $VALIDATION_WARNINGS" >> $VALIDATION_REPORT
            echo "" >> $VALIDATION_REPORT
            
            if [ $VALIDATION_ERRORS -eq 0 ]; then
                echo "âœ… Infrastructure validation completed successfully"
                echo "  Errors: $VALIDATION_ERRORS"
                echo "  Warnings: $VALIDATION_WARNINGS"
                log_validation "INFO" "Infrastructure validation completed successfully"
                
                # Create validation success artifact
                echo "{" > validation-results.json
                echo "  \"status\": \"success\"," >> validation-results.json
                echo "  \"errors\": $VALIDATION_ERRORS," >> validation-results.json
                echo "  \"warnings\": $VALIDATION_WARNINGS," >> validation-results.json
                echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> validation-results.json
                echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> validation-results.json
                echo "  \"cdk_synthesis\": \"success\"," >> validation-results.json
                echo "  \"iam_permissions\": \"validated\"," >> validation-results.json
                echo "  \"resource_configuration\": \"validated\"" >> validation-results.json
                echo "}" >> validation-results.json
            else
                echo "âŒ Infrastructure validation failed"
                echo "  Errors: $VALIDATION_ERRORS"
                echo "  Warnings: $VALIDATION_WARNINGS"
                echo ""
                echo "ðŸ” Please review the validation report for detailed error information and suggested fixes."
                log_validation "ERROR" "Infrastructure validation failed with $VALIDATION_ERRORS errors"
                
                # Create validation failure artifact
                echo "{" > validation-results.json
                echo "  \"status\": \"failed\"," >> validation-results.json
                echo "  \"errors\": $VALIDATION_ERRORS," >> validation-results.json
                echo "  \"warnings\": $VALIDATION_WARNINGS," >> validation-results.json
                echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> validation-results.json
                echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> validation-results.json
                echo "  \"cdk_synthesis\": \"failed\"," >> validation-results.json
                echo "  \"iam_permissions\": \"checked\"," >> validation-results.json
                echo "  \"resource_configuration\": \"checked\"" >> validation-results.json
                echo "}" >> validation-results.json
                
                # Display validation report
                echo ""
                echo "ðŸ“‹ VALIDATION REPORT:"
                echo "===================="
                cat $VALIDATION_REPORT
                
                exit 1
            fi
            
            echo ""
            echo "ðŸ“‹ Full validation report saved to: $VALIDATION_REPORT"
            echo "ðŸ“Š Validation results saved to: validation-results.json"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: validationResults
          Files:
            - "validation-report.txt"
            - "validation-results.json"
            - "cdk-synth-output.json"
            - "cdk-synth-errors.txt"

  DeployInfrastructure:
    Identifier: aws/build@v1
    DependsOn:
      - ValidateInfrastructure
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentContext
        - apiIntegration
    Configuration:
      Steps:
        - Run: |
            echo "ðŸš€ Infrastructure Deployment"
            echo "=========================="
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "ðŸ“Š Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            # Check if deployment should be skipped based on execution mode
            if [ "$SKIP_DEPLOYMENT" = "true" ]; then
                echo "â„¹ï¸ Execution mode: $EXECUTION_MODE - skipping deployment"
                echo "ðŸ”„ Trigger type: $TRIGGER_TYPE"
                echo "ðŸŒ¿ Branch: $BRANCH_NAME"
                
                # Create placeholder artifacts for downstream actions
                echo "{" > deployment-summary.json
                echo "  \"deployment_successful\": false," >> deployment-summary.json
                echo "  \"deployment_type\": \"skipped\"," >> deployment-summary.json
                echo "  \"api_sync_detected\": false," >> deployment-summary.json
                echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"," >> deployment-summary.json
                echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> deployment-summary.json
                echo "  \"trigger_type\": \"$TRIGGER_TYPE\"," >> deployment-summary.json
                echo "  \"skip_reason\": \"Execution mode: $EXECUTION_MODE\"," >> deployment-summary.json
                echo "  \"outputs\": {" >> deployment-summary.json
                echo "    \"api_url\": \"skipped\"," >> deployment-summary.json
                echo "    \"frontend_url\": \"skipped\"," >> deployment-summary.json
                echo "    \"s3_bucket\": \"skipped\"" >> deployment-summary.json
                echo "  }," >> deployment-summary.json
                echo "  \"handler_used\": \"skipped\"" >> deployment-summary.json
                echo "}" >> deployment-summary.json
                
                # Create placeholder outputs.json
                echo "{}" > outputs.json
                
                echo "âœ… Placeholder artifacts created for non-main branch"
                exit 0
            fi
            
            # Setup environment
            python3 -m venv .venv
            source .venv/bin/activate
            pip install aws-cdk-lib==2.80.0 constructs>=10.0.0,\<11.0.0 boto3>=1.34.0 pydantic>=2.7.0
            npm install -g aws-cdk@2.80.0
            
            # Read deployment context
            API_SYNC_DETECTED=$(jq -r '.api_sync_detected' deployment-context.json)
            DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-context.json)
            
            echo "ðŸ—ï¸ Starting CDK deployment..."
            echo "Deployment type: $DEPLOYMENT_TYPE"
            echo "API sync detected: $API_SYNC_DETECTED"
            
            # Deploy infrastructure
            if source .venv/bin/activate && cdk deploy --require-approval never --outputs-file outputs.json; then
                echo "âœ… CDK deployment - SUCCESS"
                
                # Extract deployment outputs
                echo "ðŸ” Extracting deployment outputs..."
                if [ -f "outputs.json" ]; then
                    API_URL=$(cat outputs.json | jq -r '.PeopleRegisterInfrastructureStack.ApiUrl // empty')
                    FRONTEND_URL=$(cat outputs.json | jq -r '.PeopleRegisterInfrastructureStack.FrontendUrl // empty')
                    S3_BUCKET=$(cat outputs.json | jq -r '.PeopleRegisterInfrastructureStack.S3BucketName // empty')
                    
                    echo "ðŸ“Š DEPLOYMENT INFORMATION:"
                    echo "API URL: $API_URL"
                    echo "Frontend URL: $FRONTEND_URL"
                    echo "S3 Bucket: $S3_BUCKET"
                    
                    # Create deployment summary
                    HANDLER_USED=$([ "$API_SYNC_DETECTED" = "true" ] && echo "integrated_api_handler" || echo "enhanced_api_handler")
                    TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
                    
                    echo "{" > deployment-summary.json
                    echo "  \"deployment_successful\": true," >> deployment-summary.json
                    echo "  \"deployment_type\": \"$DEPLOYMENT_TYPE\"," >> deployment-summary.json
                    echo "  \"api_sync_detected\": $API_SYNC_DETECTED," >> deployment-summary.json
                    echo "  \"timestamp\": \"$TIMESTAMP\"," >> deployment-summary.json
                    echo "  \"execution_mode\": \"$EXECUTION_MODE\"," >> deployment-summary.json
                    echo "  \"trigger_type\": \"$TRIGGER_TYPE\"," >> deployment-summary.json
                    echo "  \"outputs\": {" >> deployment-summary.json
                    echo "    \"api_url\": \"$API_URL\"," >> deployment-summary.json
                    echo "    \"frontend_url\": \"$FRONTEND_URL\"," >> deployment-summary.json
                    echo "    \"s3_bucket\": \"$S3_BUCKET\"" >> deployment-summary.json
                    echo "  }," >> deployment-summary.json
                    echo "  \"handler_used\": \"$HANDLER_USED\"" >> deployment-summary.json
                    echo "}" >> deployment-summary.json
                    
                    cat deployment-summary.json
                    echo "âœ… Infrastructure deployment completed successfully"
                else
                    echo "âš ï¸ outputs.json not found"
                    exit 1
                fi
            else
                echo "âŒ CDK deployment failed"
                exit 1
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentSummary
          Files:
            - "deployment-summary.json"
            - "outputs.json"

  PostDeploymentTests:
    Identifier: aws/build@v1
    DependsOn:
      - DeployInfrastructure
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentSummary
    Configuration:
      Steps:
        - Run: |
            echo "ðŸ§ª Post-Deployment Testing"
            echo "========================="
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "ðŸ“Š Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            # Check if testing should be skipped based on execution mode
            if [ "$SKIP_TESTING" = "true" ]; then
                echo "â„¹ï¸ Execution mode: $EXECUTION_MODE - skipping post-deployment tests"
                echo "ðŸ”„ Trigger type: $TRIGGER_TYPE"
                echo "ðŸŒ¿ Branch: $BRANCH_NAME"
                
                # Create placeholder test report for downstream actions
                echo "Post-Deployment Test Report" > post-deployment-test-report.txt
                echo "==========================" >> post-deployment-test-report.txt
                echo "Timestamp: $(date)" >> post-deployment-test-report.txt
                echo "Execution Mode: $EXECUTION_MODE" >> post-deployment-test-report.txt
                echo "Trigger Type: $TRIGGER_TYPE" >> post-deployment-test-report.txt
                echo "Branch: $BRANCH_NAME" >> post-deployment-test-report.txt
                echo "Status: SKIPPED (execution mode: $EXECUTION_MODE)" >> post-deployment-test-report.txt
                echo "" >> post-deployment-test-report.txt
                echo "â„¹ï¸ Tests skipped for $EXECUTION_MODE mode" >> post-deployment-test-report.txt
                echo "ðŸ”„ Trigger: $TRIGGER_TYPE" >> post-deployment-test-report.txt
                
                echo "âœ… Placeholder test report created for non-main branch"
                exit 0
            fi
            
            # Read deployment summary
            if [ -f "deployment-summary.json" ]; then
                API_URL=$(jq -r '.outputs.api_url' deployment-summary.json)
                DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-summary.json)
                HANDLER_USED=$(jq -r '.handler_used' deployment-summary.json)
                
                echo "Testing deployed infrastructure:"
                echo "API URL: $API_URL"
                echo "Deployment type: $DEPLOYMENT_TYPE"
                echo "Handler used: $HANDLER_USED"
            else
                echo "âŒ Deployment summary not found"
                exit 1
            fi
            
            # Wait for deployment to stabilize
            echo "â³ Waiting for deployment to stabilize..."
            sleep 30
            
            # Test function
            test_endpoint() {
                local endpoint="$1"
                local expected_status="$2"
                local description="$3"
                local method="${4:-GET}"
                local data="${5:-}"
                
                echo "Testing $description..."
                
                if [ "$method" = "POST" ] && [ -n "$data" ]; then
                    response=$(curl -s -w "%{http_code}" -X POST "$API_URL$endpoint" \
                        -H "Content-Type: application/json" \
                        -d "$data" -o response.json)
                else
                    response=$(curl -s -w "%{http_code}" -o response.json "$API_URL$endpoint")
                fi
                
                if [ "$response" = "$expected_status" ]; then
                    echo "âœ… $description - OK ($response)"
                    return 0
                else
                    echo "âŒ $description - FAILED ($response)"
                    echo "Response body:"
                    cat response.json 2>/dev/null || echo "No response body"
                    return 1
                fi
            }
            
            # Run comprehensive API tests
            TESTS_PASSED=true
            
            # Basic health check
            test_endpoint "/health" "200" "Health endpoint" || TESTS_PASSED=false
            
            # People endpoints
            test_endpoint "/people" "200" "People list endpoint" || TESTS_PASSED=false
            
            # Test person creation
            echo "Testing person creation..."
            create_data='{
                "firstName": "Test",
                "lastName": "User",
                "email": "test-deploy@example.com",
                "phone": "+1-555-0199",
                "dateOfBirth": "1990-01-01",
                "address": {
                    "street": "123 Test St",
                    "city": "Test City",
                    "state": "TS",
                    "zipCode": "12345",
                    "country": "USA"
                }
            }'
            
            create_response=$(curl -s -w "%{http_code}" -X POST "$API_URL/people" \
                -H "Content-Type: application/json" \
                -d "$create_data" -o create_response.json)
            
            if [ "$create_response" = "201" ]; then
                echo "âœ… Person creation - OK"
                PERSON_ID=$(jq -r '.id' create_response.json 2>/dev/null || echo "")
                
                if [ -n "$PERSON_ID" ] && [ "$PERSON_ID" != "null" ]; then
                    # Test person retrieval
                    test_endpoint "/people/$PERSON_ID" "200" "Person retrieval" || TESTS_PASSED=false
                    
                    # Clean up test person
                    delete_response=$(curl -s -w "%{http_code}" -X DELETE "$API_URL/people/$PERSON_ID" -o /dev/null)
                    if [ "$delete_response" = "204" ]; then
                        echo "âœ… Test cleanup - OK"
                    else
                        echo "âš ï¸ Test cleanup failed ($delete_response)"
                    fi
                fi
            else
                echo "âŒ Person creation - FAILED ($create_response)"
                cat create_response.json 2>/dev/null || echo "No response body"
                TESTS_PASSED=false
            fi
            
            # Test search endpoint (if available)
            test_endpoint "/people/search" "200" "People search endpoint" || echo "âš ï¸ Search endpoint not available (non-critical)"
            
            # Generate test report
            # Generate test report
            echo "Post-Deployment Test Report" > post-deployment-test-report.txt
            echo "==========================" >> post-deployment-test-report.txt
            echo "Timestamp: $(date)" >> post-deployment-test-report.txt
            echo "API URL: $API_URL" >> post-deployment-test-report.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> post-deployment-test-report.txt
            echo "Handler Used: $HANDLER_USED" >> post-deployment-test-report.txt
            if [ "$TESTS_PASSED" = true ]; then
                echo "Overall Status: PASSED" >> post-deployment-test-report.txt
            else
                echo "Overall Status: FAILED" >> post-deployment-test-report.txt
            fi
            echo "" >> post-deployment-test-report.txt
            echo "Test Results:" >> post-deployment-test-report.txt
            if test_endpoint "/health" "200" "Health endpoint" >/dev/null 2>&1; then
                echo "- Health endpoint: PASS" >> post-deployment-test-report.txt
            else
                echo "- Health endpoint: FAIL" >> post-deployment-test-report.txt
            fi
            if test_endpoint "/people" "200" "People list endpoint" >/dev/null 2>&1; then
                echo "- People list: PASS" >> post-deployment-test-report.txt
            else
                echo "- People list: FAIL" >> post-deployment-test-report.txt
            fi
            if [ "$create_response" = "201" ]; then
                echo "- Person CRUD: PASS" >> post-deployment-test-report.txt
            else
                echo "- Person CRUD: FAIL" >> post-deployment-test-report.txt
            fi
            echo "" >> post-deployment-test-report.txt
            if [ "$TESTS_PASSED" = true ]; then
                echo "âœ… All critical tests passed" >> post-deployment-test-report.txt
            else
                echo "âŒ Some tests failed" >> post-deployment-test-report.txt
            fi
            
            cat post-deployment-test-report.txt
            
            if [ "$TESTS_PASSED" = true ]; then
                echo "ðŸŽ‰ Post-deployment tests passed!"
                exit 0
            else
                echo "âŒ Some post-deployment tests failed"
                exit 1
            fi
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: testReport
          Files:
            - "post-deployment-test-report.txt"

  NotifyDeploymentStatus:
    Identifier: aws/build@v1
    DependsOn:
      - PostDeploymentTests
    Compute:
      Type: EC2
    Environment:
      Connections:
        - Role: CodeCatalystWorkflowDevelopmentRole-AWSCocha
          Name: "142728997126"
      Name: AWS
    Inputs:
      Sources:
        - WorkflowSource
      Artifacts:
        - deploymentSummary
        - testReport
    Configuration:
      Steps:
        - Run: |
            echo "ðŸ“¢ Deployment Status Notification"
            echo "================================"
            
            # Source execution mode environment variables
            source execution-mode-env.sh
            
            echo "ðŸ“Š Execution Context:"
            echo "  Mode: $EXECUTION_MODE"
            echo "  Trigger: $TRIGGER_TYPE"
            echo "  Branch: $BRANCH_NAME"
            echo "  Skip Deployment: $SKIP_DEPLOYMENT"
            echo "  Skip Testing: $SKIP_TESTING"
            echo ""
            
            # Read deployment and test results
            if [ -f "deployment-summary.json" ]; then
                API_URL=$(jq -r '.outputs.api_url' deployment-summary.json)
                FRONTEND_URL=$(jq -r '.outputs.frontend_url' deployment-summary.json)
                S3_BUCKET=$(jq -r '.outputs.s3_bucket' deployment-summary.json)
                DEPLOYMENT_TYPE=$(jq -r '.deployment_type' deployment-summary.json)
                HANDLER_USED=$(jq -r '.handler_used' deployment-summary.json)
                EXECUTION_MODE_FROM_SUMMARY=$(jq -r '.execution_mode // "unknown"' deployment-summary.json)
                TRIGGER_TYPE_FROM_SUMMARY=$(jq -r '.trigger_type // "unknown"' deployment-summary.json)
            else
                echo "âš ï¸ Deployment summary not available"
                API_URL="unknown"
                FRONTEND_URL="unknown"
                S3_BUCKET="unknown"
                DEPLOYMENT_TYPE="unknown"
                HANDLER_USED="unknown"
                EXECUTION_MODE_FROM_SUMMARY="unknown"
                TRIGGER_TYPE_FROM_SUMMARY="unknown"
            fi
            
            # Create comprehensive deployment notification based on execution mode
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "ðŸ” Infrastructure Validation Completed!" > deployment-notification.txt
                echo "=======================================" >> deployment-notification.txt
            else
                echo "ðŸš€ Infrastructure Deployment Completed Successfully!" > deployment-notification.txt
                echo "==================================================" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            echo "Execution Information:" >> deployment-notification.txt
            echo "=====================" >> deployment-notification.txt
            echo "Timestamp: $(date)" >> deployment-notification.txt
            echo "Execution Mode: $EXECUTION_MODE" >> deployment-notification.txt
            echo "Trigger Type: $TRIGGER_TYPE" >> deployment-notification.txt
            echo "Branch: $BRANCH_NAME" >> deployment-notification.txt
            echo "Commit: ${CODECATALYST_SOURCE_BRANCH_REF:-unknown}" >> deployment-notification.txt
            echo "Deployment Type: $DEPLOYMENT_TYPE" >> deployment-notification.txt
            echo "Handler Used: $HANDLER_USED" >> deployment-notification.txt
            echo "" >> deployment-notification.txt
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "Validation Results:" >> deployment-notification.txt
                echo "==================" >> deployment-notification.txt
                echo "âœ… API Code Synchronization: Validated" >> deployment-notification.txt
                echo "âœ… API Integration: Validated" >> deployment-notification.txt
                echo "âœ… Infrastructure Configuration: Validated" >> deployment-notification.txt
                echo "â­ï¸ Deployment: Skipped (validation mode)" >> deployment-notification.txt
                echo "â­ï¸ Testing: Skipped (validation mode)" >> deployment-notification.txt
            else
                echo "Deployed Resources:" >> deployment-notification.txt
                echo "==================" >> deployment-notification.txt
                echo "ðŸŒ API Gateway: $API_URL" >> deployment-notification.txt
                echo "ðŸŽ¨ Frontend (CloudFront): $FRONTEND_URL" >> deployment-notification.txt
                echo "ðŸ“¦ S3 Bucket: $S3_BUCKET" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            echo "Integration Status:" >> deployment-notification.txt
            echo "==================" >> deployment-notification.txt
            if [ "$DEPLOYMENT_TYPE" = "api_sync" ]; then
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    echo "âœ… Registry-API code integration validated" >> deployment-notification.txt
                else
                    echo "âœ… Registry-API code successfully integrated" >> deployment-notification.txt
                fi
            else
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    echo "â„¹ï¸ Infrastructure handlers validation completed" >> deployment-notification.txt
                else
                    echo "â„¹ï¸ Using existing infrastructure handlers" >> deployment-notification.txt
                fi
            fi
            if [ -f "post-deployment-test-report.txt" ]; then
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    echo "â­ï¸ Post-deployment tests skipped (validation mode)" >> deployment-notification.txt
                else
                    echo "âœ… Post-deployment tests completed" >> deployment-notification.txt
                fi
            else
                echo "âš ï¸ Post-deployment tests not available" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            echo "Next Steps:" >> deployment-notification.txt
            echo "==========" >> deployment-notification.txt
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "1. Review validation results and fix any issues" >> deployment-notification.txt
                echo "2. Merge pull request after validation passes" >> deployment-notification.txt
                echo "3. Full deployment will run automatically on main branch" >> deployment-notification.txt
                echo "4. Monitor for any integration issues" >> deployment-notification.txt
            else
                echo "1. Verify API endpoints are working correctly" >> deployment-notification.txt
                echo "2. Update frontend configuration if needed" >> deployment-notification.txt
                echo "3. Monitor application performance and logs" >> deployment-notification.txt
                echo "4. Coordinate with registry-api team for any issues" >> deployment-notification.txt
            fi
            echo "" >> deployment-notification.txt
            if [ "$DEPLOYMENT_TYPE" = "api_sync" ]; then
                if [ "$EXECUTION_MODE" = "validation" ]; then
                    echo "ðŸ”„ This validation included synchronized code from registry-api repository" >> deployment-notification.txt
                else
                    echo "ðŸ”„ This deployment included synchronized code from registry-api repository" >> deployment-notification.txt
                fi
                echo "" >> deployment-notification.txt
            fi
            if [ "$EXECUTION_MODE" = "validation" ]; then
                echo "Validation completed successfully! âœ…" >> deployment-notification.txt
            else
                echo "Deployment completed successfully! ðŸŽ‰" >> deployment-notification.txt
            fi
            
            cat deployment-notification.txt
            
            # Store notification for potential external systems
            echo "ðŸ“¤ Storing deployment notification..."
            
            # This could be extended to send notifications to Slack, email, etc.
            echo "âœ… Deployment notification completed"
      Container:
        Registry: CODECATALYST
        Image: CodeCatalystLinux_x86_64:2024_03
    Outputs:
      Artifacts:
        - Name: deploymentNotification
          Files:
            - "deployment-notification.txt"